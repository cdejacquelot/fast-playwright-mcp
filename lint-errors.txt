src/diagnostics/element-discovery.ts:416:15 suppressions/unused ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  ! Suppression comment has no effect. Remove the suppression or make sure you are suppressing the correct rule.
  
    415 │             alternatives.push({
  > 416 │               // biome-ignore lint/nursery/noAwaitInLoop: Sequential selector generation required for element processing
        │               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    417 │               selector: await this.generateSelector(element),
    418 │               confidence: 0.6,
  

src/context.ts:136:9 lint/suspicious/noConsole  FIXABLE  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Don't use console.
  
    134 │     if (!this._tabs.length) {
    135 │       this.closeBrowserContext().catch((error) => {
  > 136 │         console.error('Error closing browser context:', error);
        │         ^^^^^^^^^^^^^
    137 │       });
    138 │     }
  
  i The use of console is often reserved for debugging.
  
  i Unsafe fix: Remove console.
  
    134 134 │       if (!this._tabs.length) {
    135 135 │         this.closeBrowserContext().catch((error) => {
    136     │ - ········console.error('Error·closing·browser·context:',·error);
    137 136 │         });
    138 137 │       }
  

src/diagnostics/UnifiedSystem.ts:439:13 parse ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × `await` is only allowed within async functions and at the top levels of modules.
  
    437 │         () => {
    438 │           const recommendation =
  > 439 │             await this.pageAnalyzer?.shouldUseParallelAnalysis();
        │             ^^^^^
    440 │ 
    441 │           if (recommendation.recommended || forceParallel) {
  

src/diagnostics/UnifiedSystem.ts:442:20 parse ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × `await` is only allowed within async functions and at the top levels of modules.
  
    441 │           if (recommendation.recommended || forceParallel) {
  > 442 │             return await this.parallelAnalyzer?.runParallelAnalysis();
        │                    ^^^^^
    443 │           }
    444 │           return await this.pageAnalyzer?.analyzePageStructure();
  

src/diagnostics/UnifiedSystem.ts:444:18 parse ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × `await` is only allowed within async functions and at the top levels of modules.
  
    442 │             return await this.parallelAnalyzer?.runParallelAnalysis();
    443 │           }
  > 444 │           return await this.pageAnalyzer?.analyzePageStructure();
        │                  ^^^^^
    445 │         }
    446 │       );
  

src/diagnostics/UnifiedSystem.ts:303:11 lint/complexity/noExcessiveCognitiveComplexity ━━━━━━━━━━━━━

  × Excessive complexity of 16 detected (max: 15).
  
    301 │   }
    302 │ 
  > 303 │   private recordOperation(
        │           ^^^^^^^^^^^^^^^
    304 │     operation: string,
    305 │     component: DiagnosticComponent,
  
  i Please refactor this function to reduce its complexity score from 16 to the max allowed complexity 15.
  

src/diagnostics/UnifiedSystem.ts:534:3 lint/complexity/noExcessiveCognitiveComplexity ━━━━━━━━━━━━━━

  × Excessive complexity of 32 detected (max: 15).
  
    533 │   // Configuration impact reporting
  > 534 │   getConfigurationReport(): {
        │   ^^^^^^^^^^^^^^^^^^^^^^
    535 │     configurationStatus: 'default' | 'customized' | 'heavily-customized';
    536 │     appliedOverrides: {
  
  i Please refactor this function to reduce its complexity score from 32 to the max allowed complexity 15.
  

src/diagnostics/UnifiedSystem.ts:726:3 lint/suspicious/useAwait ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This async function lacks an await expression.
  
    725 │   // Health check functionality
  > 726 │   async performHealthCheck(): Promise<{
        │   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  > 727 │     status: 'healthy' | 'warning' | 'critical';
         ...
  > 792 │     return { status, issues, recommendations };
  > 793 │   }
        │   ^
    794 │ 
    795 │   // Cleanup and disposal
  
  i Remove this async modifier, or add an await expression in the function.
  
    725 │   // Health check functionality
  > 726 │   async performHealthCheck(): Promise<{
        │   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  > 727 │     status: 'healthy' | 'warning' | 'critical';
         ...
  > 792 │     return { status, issues, recommendations };
  > 793 │   }
        │   ^
    794 │ 
    795 │   // Cleanup and disposal
  
  i Async functions without await expressions may not need to be declared async.
  

src/diagnostics/UnifiedSystem.ts:788:11 lint/style/noNestedTernary ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Do not nest ternary expressions.
  
    786 │       issues.length > 2
    787 │         ? 'critical'
  > 788 │         : issues.length > 0
        │           ^^^^^^^^^^^^^^^^^
  > 789 │           ? 'warning'
  > 790 │           : 'healthy';
        │           ^^^^^^^^^^^
    791 │ 
    792 │     return { status, issues, recommendations };
  
  i Nesting ternary expressions can make code more difficult to understand.
  
  i Convert nested ternary expression into if-else statements or separate the conditions to make the logic easier to understand.
  

src/diagnostics/UnifiedSystem.ts lint/style/useFilenamingConvention ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × The filename should be in kebab-case.
  
  i The filename could be renamed to one of the following names:
    unified-system.ts
  

src/diagnostics/UnifiedSystem.ts:277:13 lint/nursery/noShadow ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This variable shadows another variable with the same name in the outer scope.
  
    276 │       // Create enhanced diagnostic error
  > 277 │       const diagnosticError =
        │             ^^^^^^^^^^^^^^^
    278 │         error instanceof DiagnosticError
    279 │           ? error
  
  i This is the shadowed variable, which is now inaccessible in the inner scope.
  
     6 │ import {
     7 │   createDiagnosticLogger,
   > 8 │   diagnosticError,
       │   ^^^^^^^^^^^^^^^
     9 │   diagnosticInfo,
    10 │   diagnosticWarn,
  
  i Consider renaming this variable. It's easy to confuse the origin of variables if they share the same name.
  

src/diagnostics/UnifiedSystem.ts:8:3 lint/correctness/noUnusedImports  FIXABLE  ━━━━━━━━━━━━━━━━━━━━

  × Several of these imports are unused.
  
     6 │ import {
     7 │   createDiagnosticLogger,
   > 8 │   diagnosticError,
       │   ^^^^^^^^^^^^^^^^
   > 9 │   diagnosticInfo,
  > 10 │   diagnosticWarn,
       │   ^^^^^^^^^^^^^^
    11 │ } from './common/diagnostic-base.js';
    12 │ import {
  
  i Unused imports might be the result of an incomplete refactoring.
  
  i Unsafe fix: Remove the unused imports.
  
      6   6 │   import {
      7   7 │     createDiagnosticLogger,
      8     │ - ··diagnosticError,
      9     │ - ··diagnosticInfo,
     10     │ - ··diagnosticWarn,
     11   8 │   } from './common/diagnostic-base.js';
     12   9 │   import {
  

src/diagnostics/UnifiedSystem.ts:439:13 parse ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × `await` is only allowed within async functions and at the top levels of modules.
  
    437 │         () => {
    438 │           const recommendation =
  > 439 │             await this.pageAnalyzer?.shouldUseParallelAnalysis();
        │             ^^^^^
    440 │ 
    441 │           if (recommendation.recommended || forceParallel) {
  

src/diagnostics/UnifiedSystem.ts:442:20 parse ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × `await` is only allowed within async functions and at the top levels of modules.
  
    441 │           if (recommendation.recommended || forceParallel) {
  > 442 │             return await this.parallelAnalyzer?.runParallelAnalysis();
        │                    ^^^^^
    443 │           }
    444 │           return await this.pageAnalyzer?.analyzePageStructure();
  

src/diagnostics/UnifiedSystem.ts:444:18 parse ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × `await` is only allowed within async functions and at the top levels of modules.
  
    442 │             return await this.parallelAnalyzer?.runParallelAnalysis();
    443 │           }
  > 444 │           return await this.pageAnalyzer?.analyzePageStructure();
        │                  ^^^^^
    445 │         }
    446 │       );
  

src/diagnostics/common/error-enrichment-utils.ts:230:17 lint/complexity/noExcessiveCognitiveComplexity ━━━━━━━━━━

  × Excessive complexity of 18 detected (max: 15).
  
    228 │  * Analyze error frequency and patterns
    229 │  */
  > 230 │ export function analyzeErrorPatterns(
        │                 ^^^^^^^^^^^^^^^^^^^^
    231 │   errors: Array<{ error: Error; timestamp: number; context: ErrorContext }>
    232 │ ): {
  
  i Please refactor this function to reduce its complexity score from 18 to the max allowed complexity 15.
  

src/diagnostics/diagnostic-level.ts:157:14 lint/suspicious/noExplicitAny ━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Unexpected any. Specify a different type.
  
    155 │   updateConfig(partial: Partial<DiagnosticConfig>): void {
    156 │     const updatedConfig = this.mergeConfig({ ...this.config, ...partial });
  > 157 │     (this as any).config = updatedConfig;
        │              ^^^
    158 │   }
    159 │ 
  
  i any disables many type checking rules. Its use should be avoided.
  

src/diagnostics/diagnostic-thresholds.ts:130:3 lint/complexity/noExcessiveCognitiveComplexity ━━━━━━━━━━

  × Excessive complexity of 25 detected (max: 15).
  
    128 │    * Get current threshold settings in MetricsThresholds format
    129 │    */
  > 130 │   getMetricsThresholds(): MetricsThresholds {
        │   ^^^^^^^^^^^^^^^^^^^^
    131 │     const thresholds = this.currentThresholds;
    132 │     return {
  
  i Please refactor this function to reduce its complexity score from 25 to the max allowed complexity 15.
  

src/diagnostics/diagnostic-thresholds.ts:263:5 lint/style/useBlockStatements  FIXABLE  ━━━━━━━━━━━━━

  × Block statements are preferred in this position.
  
    261 │     config: DiagnosticThresholdsConfig
    262 │   ): void {
  > 263 │     if (!config.executionTime) return;
        │     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    264 │ 
    265 │     const { executionTime } = config;
  
  i Unsafe fix: Wrap the statement with a `JsBlockStatement`
  
    263 │ ····if·(!config.executionTime)·{·return;·}
        │                                ++       ++

src/diagnostics/diagnostic-thresholds.ts:285:5 lint/style/useBlockStatements  FIXABLE  ━━━━━━━━━━━━━

  × Block statements are preferred in this position.
  
    283 │     config: DiagnosticThresholdsConfig
    284 │   ): void {
  > 285 │     if (!config.memory) return;
        │     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
    286 │ 
    287 │     const { memory } = config;
  
  i Unsafe fix: Wrap the statement with a `JsBlockStatement`
  
    285 │ ····if·(!config.memory)·{·return;·}
        │                         ++       ++

src/diagnostics/diagnostic-thresholds.ts:303:5 lint/style/useBlockStatements  FIXABLE  ━━━━━━━━━━━━━

  × Block statements are preferred in this position.
  
    301 │     config: DiagnosticThresholdsConfig
    302 │   ): void {
  > 303 │     if (!config.performance) return;
        │     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    304 │ 
    305 │     const { performance } = config;
  
  i Unsafe fix: Wrap the statement with a `JsBlockStatement`
  
    303 │ ····if·(!config.performance)·{·return;·}
        │                              ++       ++

src/diagnostics/diagnostic-thresholds.ts:322:5 lint/style/useBlockStatements  FIXABLE  ━━━━━━━━━━━━━

  × Block statements are preferred in this position.
  
    320 │     config: DiagnosticThresholdsConfig
    321 │   ): void {
  > 322 │     if (!config.dom) return;
        │     ^^^^^^^^^^^^^^^^^^^^^^^^
    323 │ 
    324 │     const { dom } = config;
  
  i Unsafe fix: Wrap the statement with a `JsBlockStatement`
  
    322 │ ····if·(!config.dom)·{·return;·}
        │                      ++       ++

src/diagnostics/diagnostic-thresholds.ts:355:5 lint/style/useBlockStatements  FIXABLE  ━━━━━━━━━━━━━

  × Block statements are preferred in this position.
  
    353 │     config: DiagnosticThresholdsConfig
    354 │   ): void {
  > 355 │     if (!config.interaction) return;
        │     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    356 │ 
    357 │     const { interaction } = config;
  
  i Unsafe fix: Wrap the statement with a `JsBlockStatement`
  
    355 │ ····if·(!config.interaction)·{·return;·}
        │                              ++       ++

src/diagnostics/diagnostic-thresholds.ts:373:5 lint/style/useBlockStatements  FIXABLE  ━━━━━━━━━━━━━

  × Block statements are preferred in this position.
  
    371 │     config: DiagnosticThresholdsConfig
    372 │   ): void {
  > 373 │     if (!config.layout) return;
        │     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
    374 │ 
    375 │     const { layout } = config;
  
  i Unsafe fix: Wrap the statement with a `JsBlockStatement`
  
    373 │ ····if·(!config.layout)·{·return;·}
        │                         ++       ++

src/diagnostics/diagnostic-thresholds.ts:410:11 lint/complexity/noExcessiveCognitiveComplexity ━━━━━━━━━━

  × Excessive complexity of 18 detected (max: 15).
  
    408 │    * Validate threshold configuration
    409 │    */
  > 410 │   private validateThresholds(
        │           ^^^^^^^^^^^^^^^^^^
    411 │     thresholds: Required<DiagnosticThresholdsConfig>
    412 │   ): void {
  
  i Please refactor this function to reduce its complexity score from 18 to the max allowed complexity 15.
  

src/diagnostics/element-discovery.ts:171:45 lint/nursery/noShadow ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This variable shadows another variable with the same name in the outer scope.
  
    169 │             const [textContent, value, placeholder, ariaLabel] =
    170 │               await Promise.all([
  > 171 │                 element.textContent().then((text) => text || ''),
        │                                             ^^^^
    172 │                 element.getAttribute('value').then((attr) => attr || ''),
    173 │                 element.getAttribute('placeholder').then((attr) => attr || ''),
  
  i This is the shadowed variable, which is now inaccessible in the inner scope.
  
    134 │   private async findByText(
  > 135 │     text: string,
        │     ^^^^
    136 │     maxResults: number
    137 │   ): Promise<AlternativeElement[]> {
  
  i Consider renaming this variable. It's easy to confuse the origin of variables if they share the same name.
  

src/diagnostics/enhanced-error-handler.ts:477:17 lint/complexity/noExcessiveCognitiveComplexity ━━━━━━━━━━

  × Excessive complexity of 17 detected (max: 15).
  
    475 │   }
    476 │ 
  > 477 │   private async generateContextualSuggestions(
        │                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    478 │     _error: DiagnosticError,
    479 │     component: DiagnosticComponent,
  
  i Please refactor this function to reduce its complexity score from 17 to the max allowed complexity 15.
  

src/diagnostics/enhanced-error-handler.ts:490:7 lint/style/useDefaultSwitchClause ━━━━━━━━━━━━━━━━━━

  × Expected a default switch clause.
  
    489 │       // Component-specific contextual suggestions
  > 490 │       switch (component) {
        │       ^^^^^^^^^^^^^^^^^^^^
  > 491 │         case 'PageAnalyzer':
         ...
  > 526 │           break;
  > 527 │       }
        │       ^
    528 │ 
    529 │       // Operation-specific suggestions
  
  i The lack of a default clause can be a possible omission.
  
  i Consider adding a default clause.
  

src/diagnostics/enhanced-error-handler.ts:77:43 lint/correctness/noUndeclaredVariables ━━━━━━━━━━━━━

  × The DiagnosticBase variable is undeclared.
  
    75 │ }
    76 │ 
  > 77 │ export class EnhancedErrorHandler extends DiagnosticBase {
       │                                           ^^^^^^^^^^^^^^
    78 │   private readonly pageAnalyzer: PageAnalyzer;
    79 │   private readonly elementDiscovery: ElementDiscovery;
  
  i By default, Biome recognizes browser and Node.js globals.
    You can ignore more globals using the javascript.globals configuration.
  

src/diagnostics/enhanced-error-handler.ts:381:11 lint/nursery/noShadow ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This variable shadows another variable with the same name in the outer scope.
  
    379 │     memoryUsage?: number
    380 │   ): DiagnosticError {
  > 381 │     const diagnosticError = DiagnosticError.from(error, component, operation, {
        │           ^^^^^^^^^^^^^^^
    382 │       executionTime,
    383 │       memoryUsage,
  
  i This is the shadowed variable, which is now inaccessible in the inner scope.
  
     6 │ import {
     7 │   createDiagnosticLogger,
   > 8 │   diagnosticError,
       │   ^^^^^^^^^^^^^^^
     9 │   diagnosticInfo,
    10 │   diagnosticWarn,
  
  i Consider renaming this variable. It's easy to confuse the origin of variables if they share the same name.
  

src/diagnostics/enhanced-error-handler.ts:411:11 lint/nursery/noShadow ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This variable shadows another variable with the same name in the outer scope.
  
    410 │     try {
  > 411 │       let diagnosticError: DiagnosticError;
        │           ^^^^^^^^^^^^^^^
    412 │ 
    413 │       if (error instanceof DiagnosticError) {
  
  i This is the shadowed variable, which is now inaccessible in the inner scope.
  
     6 │ import {
     7 │   createDiagnosticLogger,
   > 8 │   diagnosticError,
       │   ^^^^^^^^^^^^^^^
     9 │   diagnosticInfo,
    10 │   diagnosticWarn,
  
  i Consider renaming this variable. It's easy to confuse the origin of variables if they share the same name.
  

src/diagnostics/enhanced-error-handler.ts:8:3 lint/correctness/noUnusedImports  FIXABLE  ━━━━━━━━━━━

  × Several of these imports are unused.
  
     6 │ import {
     7 │   createDiagnosticLogger,
   > 8 │   diagnosticError,
       │   ^^^^^^^^^^^^^^^^
   > 9 │   diagnosticInfo,
  > 10 │   diagnosticWarn,
       │   ^^^^^^^^^^^^^^
    11 │ } from './common/index.js';
    12 │ import type { DiagnosticComponent } from './diagnostic-error.js';
  
  i Unused imports might be the result of an incomplete refactoring.
  
  i Unsafe fix: Remove the unused imports.
  
      6   6 │   import {
      7   7 │     createDiagnosticLogger,
      8     │ - ··diagnosticError,
      9     │ - ··diagnosticInfo,
     10     │ - ··diagnosticWarn,
     11   8 │   } from './common/index.js';
     12   9 │   import type { DiagnosticComponent } from './diagnostic-error.js';
  

src/diagnostics/error-enrichment.ts:56:38 lint/correctness/noUndeclaredVariables ━━━━━━━━━━━━━━━━━━━

  × The DiagnosticBase variable is undeclared.
  
    54 │ }
    55 │ 
  > 56 │ export class ErrorEnrichment extends DiagnosticBase {
       │                                      ^^^^^^^^^^^^^^
    57 │   private readonly pageAnalyzer: PageAnalyzer;
    58 │   private readonly elementDiscovery: ElementDiscovery;
  
  i By default, Biome recognizes browser and Node.js globals.
    You can ignore more globals using the javascript.globals configuration.
  

src/diagnostics/page-analyzer.ts:77:17 lint/complexity/noExcessiveCognitiveComplexity ━━━━━━━━━━━━━━

  × Excessive complexity of 22 detected (max: 15).
  
    75 │   }
    76 │ 
  > 77 │   private async analyzeIframes() {
       │                 ^^^^^^^^^^^^^^
    78 │     const page = this.getPage();
    79 │     const iframes = await page.$$('iframe');
  
  i Please refactor this function to reduce its complexity score from 22 to the max allowed complexity 15.
  

src/diagnostics/page-analyzer.ts:223:49 lint/complexity/noExcessiveCognitiveComplexity ━━━━━━━━━━━━━

  × Excessive complexity of 17 detected (max: 15).
  
    221 │   private async analyzeElements() {
    222 │     const page = this.getPage();
  > 223 │     const elementStats = await page.evaluate(() => {
        │                                                 ^^^
    224 │       const allElements = document.querySelectorAll('*');
    225 │       let totalVisible = 0;
  
  i Please refactor this function to reduce its complexity score from 17 to the max allowed complexity 15.
  

src/diagnostics/page-analyzer.ts:272:50 lint/complexity/noExcessiveCognitiveComplexity ━━━━━━━━━━━━━

  × Excessive complexity of 84 detected (max: 15).
  
    271 │     try {
  > 272 │       const metricsData = await page.evaluate(() => {
        │                                                  ^^^
    273 │         // DOM complexity analysis using TreeWalker for efficiency
    274 │         const getAllElementsWithTreeWalker = () => {
  
  i Please refactor this function to reduce its complexity score from 84 to the max allowed complexity 15.
  

src/diagnostics/page-analyzer.ts:283:19 lint/suspicious/noAssignInExpressions ━━━━━━━━━━━━━━━━━━━━━━

  × The assignment should not be in an expression.
  
    282 │           let node: Node | null;
  > 283 │           while ((node = walker.nextNode()) !== null) {
        │                   ^^^^^^^^^^^^^^^^^^^^^^^^
    284 │             elements.push(node as Element);
    285 │           }
  
  i The use of assignments in expressions is confusing.
    Expressions are often considered as side-effect free.
  

src/diagnostics/page-analyzer.ts:324:69 lint/complexity/noExcessiveCognitiveComplexity ━━━━━━━━━━━━━

  × Excessive complexity of 27 detected (max: 15).
  
    322 │         };
    323 │ 
  > 324 │         const analyzeSubtree = (element: Element, selector: string) => {
        │                                                                     ^^^
    325 │           const descendantCount = countDescendants(element);
    326 │           if (descendantCount >= 500) {
  
  i Please refactor this function to reduce its complexity score from 27 to the max allowed complexity 15.
  

src/diagnostics/resource-manager.ts:118:7 lint/complexity/noVoid ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × The use of void is not allowed.
  
    116 │   private startCleanupTimer(): void {
    117 │     this.cleanupInterval = setInterval(() => {
  > 118 │       void this.cleanupExpiredResources();
        │       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    119 │     }, this.disposeTimeout / 2); // Run cleanup every half of timeout period
    120 │   }
  
  i If you use void to alter the return type of a function or return `undefined`, use the global `undefined` instead.
  

src/diagnostics/smart-config.ts:475:3 lint/complexity/noExcessiveCognitiveComplexity ━━━━━━━━━━━━━━━

  × Excessive complexity of 30 detected (max: 15).
  
    473 │    * Report detailed impact of configuration changes
    474 │    */
  > 475 │   getConfigurationImpactReport(): {
        │   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    476 │     activeOverrides: string[];
    477 │     performanceImpact: {
  
  i Please refactor this function to reduce its complexity score from 30 to the max allowed complexity 15.
  

src/diagnostics/smart-handle.ts:19:5 lint/style/noParameterProperties ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Use a more explicit class property instead of a parameter property.
  
    18 │   constructor(
  > 19 │     private readonly resource: T,
       │     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    20 │     tracker?: SmartTracker
    21 │   ) {
  
  i Parameter properties are less explicit than other ways of declaring and initializing class properties.
  

src/extension/cdpRelay.ts:353:9 lint/suspicious/noImplicitAnyLet ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This variable implicitly has the any type.
  
    351 │   private _onMessage(event: websocket.RawData) {
    352 │     const eventData = event.toString();
  > 353 │     let parsedJson;
        │         ^^^^^^^^^^
    354 │     try {
    355 │       parsedJson = JSON.parse(eventData);
  
  i Variable declarations without type annotation and initialization implicitly have the any type. Declare a type or initialize the variable with some value.
  

src/extension/cdpRelay.ts:353:9 lint/suspicious/noEvolvingTypes ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × The type of this variable may evolve implicitly to any type, including the any type.
  
    351 │   private _onMessage(event: websocket.RawData) {
    352 │     const eventData = event.toString();
  > 353 │     let parsedJson;
        │         ^^^^^^^^^^
    354 │     try {
    355 │       parsedJson = JSON.parse(eventData);
  
  i Add an explicit type or initialization to avoid implicit type evolution.
  

src/extension/cdpRelay.ts:374:24 lint/style/noNonNullAssertion ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Forbidden non-null assertion.
  
    372 │   private _handleParsedMessage(object: ExtensionResponse) {
    373 │     if (object.id && this._callbacks.has(object.id)) {
  > 374 │       const callback = this._callbacks.get(object.id)!;
        │                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    375 │       this._callbacks.delete(object.id);
    376 │       if (object.error) {
  

src/extension/cdpRelay.ts:386:24 lint/style/noNonNullAssertion ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Forbidden non-null assertion.
  
    384 │       debugLogger('← Extension: unexpected response', object);
    385 │     } else {
  > 386 │       this.onmessage?.(object.method!, object.params);
        │                        ^^^^^^^^^^^^^^
    387 │     }
    388 │   }
  

src/extension/cdpRelay.ts lint/style/useFilenamingConvention ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × The filename should be in kebab-case.
  
  i The filename could be renamed to one of the following names:
    cdp-relay.ts
  

src/extension/cdpRelay.ts:293:7 lint/style/noParameterAssign ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Assigning a function parameter is confusing.
  
    291 │     // Top level sessionId is only passed between the relay and the client.
    292 │     if (this._connectedTabInfo?.sessionId === sessionId) {
  > 293 │       sessionId = undefined;
        │       ^^^^^^^^^
    294 │     }
    295 │     return await this._extensionConnection.send('forwardCDPCommand', {
  
  i The parameter is declared here:
  
    284 │     method: string,
    285 │     params: CDPParams,
  > 286 │     sessionId: string | undefined
        │     ^^^^^^^^^
    287 │   ): Promise<unknown> {
    288 │     if (!this._extensionConnection) {
  
  i Developers usually expect function parameters to be readonly. To align with this expectation, use a local variable instead.
  

src/extension/cdpRelay.ts:56:66 lint/performance/useTopLevelRegex ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This regex literal is not defined in the top level scope. This can lead to performance issues if this function is called frequently.
  
    54 │   private _extensionConnectionPromise!: ManualPromise<void>;
    55 │   constructor(server: http.Server, browserChannel: string) {
  > 56 │     this._wsHost = httpAddressToString(server.address()).replace(/^http/, 'ws');
       │                                                                  ^^^^^^^
    57 │     this._browserChannel = browserChannel;
    58 │     const uuid = crypto.randomUUID();
  
  i Move the regex literal outside of this scope, and place it at the top level of this module, as a constant.
  

src/extension/cdpRelay.ts:173:5 lint/complexity/noVoid ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × The use of void is not allowed.
  
    171 │     this._extensionConnection = null;
    172 │     this._extensionConnectionPromise = new ManualPromise();
  > 173 │     void this._extensionConnectionPromise.catch(logUnhandledError);
        │     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    174 │   }
    175 │   private _closePlaywrightConnection(reason: string) {
  
  i If you use void to alter the return type of a function or return `undefined`, use the global `undefined` instead.
  

src/extension/cdpRelay.ts:203:59 lint/suspicious/noExplicitAny ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Unexpected any. Specify a different type.
  
    201 │     this._extensionConnectionPromise.resolve();
    202 │   }
  > 203 │   private _handleExtensionMessage(method: string, params: any) {
        │                                                           ^^^
    204 │     switch (method) {
    205 │       case 'forwardCDPEvent': {
  
  i any disables many type checking rules. Its use should be avoided.
  

src/extension/cdpRelay.ts:204:5 lint/style/useDefaultSwitchClause ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Expected a default switch clause.
  
    202 │   }
    203 │   private _handleExtensionMessage(method: string, params: any) {
  > 204 │     switch (method) {
        │     ^^^^^^^^^^^^^^^^^
  > 205 │       case 'forwardCDPEvent': {
         ...
  > 217 │         break;
  > 218 │     }
        │     ^
    219 │   }
    220 │   private async _handlePlaywrightMessage(message: CDPCommand): Promise<void> {
  
  i The lack of a default clause can be a possible omission.
  
  i Consider adding a default clause.
  

src/extension/cdpRelay.ts:240:5 lint/style/useDefaultSwitchClause ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Expected a default switch clause.
  
    238 │     sessionId: string | undefined
    239 │   ): Promise<unknown> {
  > 240 │     switch (method) {
        │     ^^^^^^^^^^^^^^^^^
  > 241 │       case 'Browser.getVersion': {
         ...
  > 279 │       }
  > 280 │     }
        │     ^
    281 │     return await this._forwardToExtension(method, params, sessionId);
    282 │   }
  
  i The lack of a default clause can be a possible omission.
  
  i Consider adding a default clause.
  

src/extension/cdpRelay.ts:258:42 lint/correctness/noUnsafeOptionalChaining ━━━━━━━━━━━━━━━━━━━━━━━━━

  × Unsafe usage of optional chaining.
  
    256 │         // Simulate auto-attach behavior with real target info
    257 │         const { targetInfo } =
  > 258 │           await this._extensionConnection?.send('attachToTab');
        │                                          ^^
    259 │         this._connectedTabInfo = {
    260 │           targetInfo,
  
  i If it short-circuits with 'undefined' the evaluation will throw TypeError here:
  
    255 │         }
    256 │         // Simulate auto-attach behavior with real target info
  > 257 │         const { targetInfo } =
        │               ^^^^^^^^^^^^^^^^
  > 258 │           await this._extensionConnection?.send('attachToTab');
        │           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    259 │         this._connectedTabInfo = {
    260 │           targetInfo,
  

src/extension/cdpRelay.ts:312:12 lint/suspicious/noExplicitAny ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Unexpected any. Specify a different type.
  
    310 │   id?: number;
    311 │   method?: string;
  > 312 │   params?: any;
        │            ^^^
    313 │   result?: any;
    314 │   error?: string;
  
  i any disables many type checking rules. Its use should be avoided.
  

src/extension/cdpRelay.ts:313:12 lint/suspicious/noExplicitAny ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Unexpected any. Specify a different type.
  
    311 │   method?: string;
    312 │   params?: any;
  > 313 │   result?: any;
        │            ^^^
    314 │   error?: string;
    315 │ };
  
  i any disables many type checking rules. Its use should be avoided.
  

src/extension/cdpRelay.ts:320:20 lint/suspicious/noExplicitAny ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Unexpected any. Specify a different type.
  
    318 │   private readonly _callbacks = new Map<
    319 │     number,
  > 320 │     { resolve: (o: any) => void; reject: (e: Error) => void; error: Error }
        │                    ^^^
    321 │   >();
    322 │   onmessage?: (method: string, params: any) => void;
  
  i any disables many type checking rules. Its use should be avoided.
  

src/extension/cdpRelay.ts:322:40 lint/suspicious/noExplicitAny ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Unexpected any. Specify a different type.
  
    320 │     { resolve: (o: any) => void; reject: (e: Error) => void; error: Error }
    321 │   >();
  > 322 │   onmessage?: (method: string, params: any) => void;
        │                                        ^^^
    323 │   onclose?: (self: ExtensionConnection, reason: string) => void;
    324 │   constructor(ws: WebSocket) {
  
  i any disables many type checking rules. Its use should be avoided.
  

src/extension/cdpRelay.ts:330:3 lint/suspicious/useAwait ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This async function lacks an await expression.
  
    328 │     this._ws.on('error', this._onError.bind(this));
    329 │   }
  > 330 │   async send(
        │   ^^^^^^^^^^^
  > 331 │     method: string,
         ...
  > 343 │     });
  > 344 │   }
        │   ^
    345 │   close(message: string) {
    346 │     debugLogger('closing extension connection:', message);
  
  i Remove this async modifier, or add an await expression in the function.
  
    328 │     this._ws.on('error', this._onError.bind(this));
    329 │   }
  > 330 │   async send(
        │   ^^^^^^^^^^^
  > 331 │     method: string,
         ...
  > 343 │     });
  > 344 │   }
        │   ^
    345 │   close(message: string) {
    346 │     debugLogger('closing extension connection:', message);
  
  i Async functions without await expressions may not need to be declared async.
  

src/extension/extensionContextFactory.ts:2:8 lint/performance/noNamespaceImport ━━━━━━━━━━━━━━━━━━━━

  × Avoid namespace imports, it can prevent efficient tree shaking and increase bundle size.
  
    1 │ import debug from 'debug';
  > 2 │ import * as playwright from 'playwright';
      │        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    3 │ import type {
    4 │   BrowserContextFactory,
  
  i Use named imports instead.
  

src/extension/extensionContextFactory.ts lint/style/useFilenamingConvention ━━━━━━━━━━━━━━━━━━━━━━━━

  × The filename should be in kebab-case.
  
  i The filename could be renamed to one of the following names:
    extension-context-factory.ts
  

src/extension/main.ts:3:8 lint/performance/noNamespaceImport ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Avoid namespace imports, it can prevent efficient tree shaking and increase bundle size.
  
    1 │ import { BrowserServerBackend } from '../browser-server-backend.js';
    2 │ import type { FullConfig } from '../config.js';
  > 3 │ import * as mcpTransport from '../mcp/transport.js';
      │        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    4 │ import { ExtensionContextFactory } from './extensionContextFactory.js';
    5 │ export async function runWithExtension(config: FullConfig) {
  
  i Use named imports instead.
  

src/fileUtils.ts:19:8 lint/suspicious/useAwait ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This async function lacks an await expression.
  
    17 │   return path.join(cacheDirectory, 'ms-playwright');
    18 │ }
  > 19 │ export async function userDataDir(browserConfig: FullConfig['browser']) {
       │        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  > 20 │   return path.join(
  > 21 │     cacheDir(),
  > 22 │     'ms-playwright',
  > 23 │     `mcp-${browserConfig.launchOptions?.channel ?? browserConfig?.browserName}-profile`
  > 24 │   );
  > 25 │ }
       │ ^
    26 │ 
  
  i Remove this async modifier, or add an await expression in the function.
  
    17 │   return path.join(cacheDirectory, 'ms-playwright');
    18 │ }
  > 19 │ export async function userDataDir(browserConfig: FullConfig['browser']) {
       │        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  > 20 │   return path.join(
  > 21 │     cacheDir(),
  > 22 │     'ms-playwright',
  > 23 │     `mcp-${browserConfig.launchOptions?.channel ?? browserConfig?.browserName}-profile`
  > 24 │   );
  > 25 │ }
       │ ^
    26 │ 
  
  i Async functions without await expressions may not need to be declared async.
  

src/fileUtils.ts lint/style/useFilenamingConvention ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × The filename should be in kebab-case.
  
  i The filename could be renamed to one of the following names:
    file-utils.ts
  

src/httpServer.ts lint/style/useFilenamingConvention ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × The filename should be in kebab-case.
  
  i The filename could be renamed to one of the following names:
    http-server.ts
  

src/index.ts:8:8 lint/performance/noNamespaceImport ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Avoid namespace imports, it can prevent efficient tree shaking and increase bundle size.
  
     6 │ import { BrowserServerBackend } from './browser-server-backend.js';
     7 │ import { resolveConfig } from './config.js';
   > 8 │ import * as mcpServer from './mcp/server.js';
       │        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
     9 │ export async function createConnection(
    10 │   userConfig: Config = {},
  
  i Use named imports instead.
  

src/loop/loop.ts:39:23 lint/complexity/noExcessiveCognitiveComplexity ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Excessive complexity of 23 detected (max: 15).
  
    37 │   checkDoneToolCall(toolCall: LLMToolCall): string | null;
    38 │ }
  > 39 │ export async function runTask(
       │                       ^^^^^^^
    40 │   delegate: LLMDelegate,
    41 │   client: Client,
  
  i Please refactor this function to reduce its complexity score from 23 to the max allowed complexity 15.
  

src/loop/loopClaude.ts:50:9 lint/complexity/noExcessiveCognitiveComplexity ━━━━━━━━━━━━━━━━━━━━━━━━━

  × Excessive complexity of 23 detected (max: 15).
  
    48 │     };
    49 │   }
  > 50 │   async makeApiCall(conversation: LLMConversation): Promise<LLMToolCall[]> {
       │         ^^^^^^^^^^^
    51 │     // Convert generic messages to Claude format
    52 │     const claudeMessages: Anthropic.Messages.MessageParam[] = [];
  
  i Please refactor this function to reduce its complexity score from 23 to the max allowed complexity 15.
  

src/loop/loopClaude.ts lint/style/useFilenamingConvention ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × The filename should be in kebab-case.
  
  i The filename could be renamed to one of the following names:
    loop-claude.ts
  

src/loop/loopOpenAI.ts:50:9 lint/complexity/noExcessiveCognitiveComplexity ━━━━━━━━━━━━━━━━━━━━━━━━━

  × Excessive complexity of 23 detected (max: 15).
  
    48 │     };
    49 │   }
  > 50 │   async makeApiCall(conversation: LLMConversation): Promise<LLMToolCall[]> {
       │         ^^^^^^^^^^^
    51 │     // Convert generic messages to OpenAI format
    52 │     const openaiMessages: OpenAI.Chat.Completions.ChatCompletionMessageParam[] =
  
  i Please refactor this function to reduce its complexity score from 23 to the max allowed complexity 15.
  

src/loop/loopOpenAI.ts lint/style/useFilenamingConvention ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × The filename should be in kebab-case.
  
  i The filename could be renamed to one of the following names:
    loop-open-ai.ts
  

src/loopTools/context.ts:11:8 lint/performance/noNamespaceImport ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Avoid namespace imports, it can prevent efficient tree shaking and increase bundle size.
  
     9 │ import { OpenAIDelegate } from '../loop/loopOpenAI.js';
    10 │ import { InProcessTransport } from '../mcp/inProcessTransport.js';
  > 11 │ import * as mcpServer from '../mcp/server.js';
       │        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    12 │ export class Context {
    13 │   readonly config: FullConfig;
  
  i Use named imports instead.
  

src/loopTools/context.ts:46:7 lint/style/noNonNullAssertion ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Forbidden non-null assertion.
  
    44 │     const messages = await runTask(
    45 │       this._delegate,
  > 46 │       this._client!,
       │       ^^^^^^^^^^^^^
    47 │       task,
    48 │       oneShot
  

src/loopTools/main.ts:5:8 lint/performance/noNamespaceImport ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Avoid namespace imports, it can prevent efficient tree shaking and increase bundle size.
  
    3 │ import type * as mcpServer from '../mcp/server.js';
    4 │ import type { ServerBackend } from '../mcp/server.js';
  > 5 │ import * as mcpTransport from '../mcp/transport.js';
      │        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    6 │ import { packageJSON } from '../package.js';
    7 │ import { Context } from './context.js';
  
  i Use named imports instead.
  

src/loopTools/main.ts:35:18 lint/style/noNonNullAssertion ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Forbidden non-null assertion.
  
    33 │     parsedArguments: Record<string, unknown>
    34 │   ): Promise<mcpServer.ToolResponse> {
  > 35 │     const tool = this._tools.find((tool) => tool.schema.name === schema.name)!;
       │                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    36 │     return await tool.handle(this._context!, parsedArguments);
    37 │   }
  

src/loopTools/main.ts:36:30 lint/style/noNonNullAssertion ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Forbidden non-null assertion.
  
    34 │   ): Promise<mcpServer.ToolResponse> {
    35 │     const tool = this._tools.find((tool) => tool.schema.name === schema.name)!;
  > 36 │     return await tool.handle(this._context!, parsedArguments);
       │                              ^^^^^^^^^^^^^^
    37 │   }
    38 │   serverClosed() {
  

src/loopTools/main.ts:39:5 lint/complexity/noVoid ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × The use of void is not allowed.
  
    37 │   }
    38 │   serverClosed() {
  > 39 │     void this._context?.close();
       │     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
    40 │   }
    41 │ }
  
  i If you use void to alter the return type of a function or return `undefined`, use the global `undefined` instead.
  

src/loopTools/main.ts:35:36 lint/nursery/noShadow ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This variable shadows another variable with the same name in the outer scope.
  
    33 │     parsedArguments: Record<string, unknown>
    34 │   ): Promise<mcpServer.ToolResponse> {
  > 35 │     const tool = this._tools.find((tool) => tool.schema.name === schema.name)!;
       │                                    ^^^^
    36 │     return await tool.handle(this._context!, parsedArguments);
    37 │   }
  
  i This is the shadowed variable, which is now inaccessible in the inner scope.
  
    33 │     parsedArguments: Record<string, unknown>
    34 │   ): Promise<mcpServer.ToolResponse> {
  > 35 │     const tool = this._tools.find((tool) => tool.schema.name === schema.name)!;
       │           ^^^^
    36 │     return await tool.handle(this._context!, parsedArguments);
    37 │   }
  
  i Consider renaming this variable. It's easy to confuse the origin of variables if they share the same name.
  

src/manualPromise.ts:13:21 lint/style/noNonNullAssertion ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Forbidden non-null assertion.
  
    11 │     });
    12 │     this._isDone = false;
  > 13 │     this._resolve = resolve!;
       │                     ^^^^^^^^
    14 │     this._reject = reject!;
    15 │   }
  

src/manualPromise.ts:14:20 lint/style/noNonNullAssertion ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Forbidden non-null assertion.
  
    12 │     this._isDone = false;
    13 │     this._resolve = resolve!;
  > 14 │     this._reject = reject!;
       │                    ^^^^^^^
    15 │   }
    16 │   isDone() {
  

src/manualPromise.ts:56:3 lint/suspicious/useAwait ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This async function lacks an await expression.
  
    54 │     return this._isClosed;
    55 │   }
  > 56 │   static async raceMultiple<T>(
       │   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  > 57 │     scopes: LongStandingScope[],
  > 58 │     promise: Promise<T>
  > 59 │   ): Promise<T> {
  > 60 │     return Promise.race(scopes.map((s) => s.race(promise)));
  > 61 │   }
       │   ^
    62 │   async race<T>(promise: Promise<T> | Promise<T>[]): Promise<T> {
    63 │     return this._race(
  
  i Remove this async modifier, or add an await expression in the function.
  
    54 │     return this._isClosed;
    55 │   }
  > 56 │   static async raceMultiple<T>(
       │   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  > 57 │     scopes: LongStandingScope[],
  > 58 │     promise: Promise<T>
  > 59 │   ): Promise<T> {
  > 60 │     return Promise.race(scopes.map((s) => s.race(promise)));
  > 61 │   }
       │   ^
    62 │   async race<T>(promise: Promise<T> | Promise<T>[]): Promise<T> {
    63 │     return this._race(
  
  i Async functions without await expressions may not need to be declared async.
  

src/manualPromise.ts:62:3 lint/suspicious/useAwait ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This async function lacks an await expression.
  
    60 │     return Promise.race(scopes.map((s) => s.race(promise)));
    61 │   }
  > 62 │   async race<T>(promise: Promise<T> | Promise<T>[]): Promise<T> {
       │   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  > 63 │     return this._race(
  > 64 │       Array.isArray(promise) ? promise : [promise],
  > 65 │       false
  > 66 │     ) as Promise<T>;
  > 67 │   }
       │   ^
    68 │   async safeRace<T>(promise: Promise<T>, defaultValue?: T): Promise<T> {
    69 │     return this._race([promise], true, defaultValue);
  
  i Remove this async modifier, or add an await expression in the function.
  
    60 │     return Promise.race(scopes.map((s) => s.race(promise)));
    61 │   }
  > 62 │   async race<T>(promise: Promise<T> | Promise<T>[]): Promise<T> {
       │   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  > 63 │     return this._race(
  > 64 │       Array.isArray(promise) ? promise : [promise],
  > 65 │       false
  > 66 │     ) as Promise<T>;
  > 67 │   }
       │   ^
    68 │   async safeRace<T>(promise: Promise<T>, defaultValue?: T): Promise<T> {
    69 │     return this._race([promise], true, defaultValue);
  
  i Async functions without await expressions may not need to be declared async.
  

src/manualPromise.ts:68:3 lint/suspicious/useAwait ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This async function lacks an await expression.
  
    66 │     ) as Promise<T>;
    67 │   }
  > 68 │   async safeRace<T>(promise: Promise<T>, defaultValue?: T): Promise<T> {
       │   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  > 69 │     return this._race([promise], true, defaultValue);
  > 70 │   }
       │   ^
    71 │   private async _race<T>(
    72 │     promises: Promise<T>[],
  
  i Remove this async modifier, or add an await expression in the function.
  
    66 │     ) as Promise<T>;
    67 │   }
  > 68 │   async safeRace<T>(promise: Promise<T>, defaultValue?: T): Promise<T> {
       │   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  > 69 │     return this._race([promise], true, defaultValue);
  > 70 │   }
       │   ^
    71 │   private async _race<T>(
    72 │     promises: Promise<T>[],
  
  i Async functions without await expressions may not need to be declared async.
  

src/manualPromise.ts lint/style/useFilenamingConvention ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × The filename should be in kebab-case.
  
  i The filename could be renamed to one of the following names:
    manual-promise.ts
  

src/manualPromise.ts:96:26 lint/suspicious/useErrorMessage ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Provide an error message for the error.
  
    94 │ }
    95 │ function cloneError(error: Error, frames: string[]) {
  > 96 │   const clone = new Error();
       │                          ^^
    97 │   clone.name = error.name;
    98 │   clone.message = error.message;
  
  i Providing meaningful error messages leads to more readable and debuggable code.
  

src/manualPromise.ts:105:26 lint/suspicious/useErrorMessage ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Provide an error message for the error.
  
    103 │   const stackTraceLimit = Error.stackTraceLimit;
    104 │   Error.stackTraceLimit = 50;
  > 105 │   const error = new Error();
        │                          ^^
    106 │   const stack = error.stack || '';
    107 │   Error.stackTraceLimit = stackTraceLimit;
  
  i Providing meaningful error messages leads to more readable and debuggable code.
  

src/mcp/inProcessTransport.ts:31:3 lint/suspicious/useAwait ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This async function lacks an await expression.
  
    29 │     this._serverTransport._receiveFromClient(message);
    30 │   }
  > 31 │   async close(): Promise<void> {
       │   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  > 32 │     if (this._connected) {
        ...
  > 36 │     }
  > 37 │   }
       │   ^
    38 │   onclose?: (() => void) | undefined;
    39 │   onerror?: ((error: Error) => void) | undefined;
  
  i Remove this async modifier, or add an await expression in the function.
  
    29 │     this._serverTransport._receiveFromClient(message);
    30 │   }
  > 31 │   async close(): Promise<void> {
       │   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  > 32 │     if (this._connected) {
        ...
  > 36 │     }
  > 37 │   }
       │   ^
    38 │   onclose?: (() => void) | undefined;
    39 │   onerror?: ((error: Error) => void) | undefined;
  
  i Async functions without await expressions may not need to be declared async.
  

src/mcp/inProcessTransport.ts lint/style/useFilenamingConvention ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × The filename should be in kebab-case.
  
  i The filename could be renamed to one of the following names:
    in-process-transport.ts
  

src/mcp/server.ts:73:52 lint/suspicious/useAwait ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This async function lacks an await expression.
  
    71 │   );
    72 │   const tools = backend.tools();
  > 73 │   server.setRequestHandler(ListToolsRequestSchema, async () => {
       │                                                    ^^^^^^^^^^^^^
  > 74 │     return {
        ...
  > 86 │     };
  > 87 │   });
       │   ^
    88 │   let heartbeatRunning = false;
    89 │   server.setRequestHandler(CallToolRequestSchema, async (request) => {
  
  i Remove this async modifier, or add an await expression in the function.
  
    71 │   );
    72 │   const tools = backend.tools();
  > 73 │   server.setRequestHandler(ListToolsRequestSchema, async () => {
       │                                                    ^^^^^^^^^^^^^
  > 74 │     return {
        ...
  > 86 │     };
  > 87 │   });
       │   ^
    88 │   let heartbeatRunning = false;
    89 │   server.setRequestHandler(CallToolRequestSchema, async (request) => {
  
  i Async functions without await expressions may not need to be declared async.
  

src/mcp/server.ts:100:8 lint/nursery/noShadow ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This variable shadows another variable with the same name in the outer scope.
  
     98 │     });
     99 │     const tool = tools.find(
  > 100 │       (tool) => tool.name === request.params.name
        │        ^^^^
    101 │     ) as ToolSchema<unknown>;
    102 │     if (!tool) {
  
  i This is the shadowed variable, which is now inaccessible in the inner scope.
  
     97 │       isError: true,
     98 │     });
   > 99 │     const tool = tools.find(
        │           ^^^^
    100 │       (tool) => tool.name === request.params.name
    101 │     ) as ToolSchema<unknown>;
  
  i Consider renaming this variable. It's easy to confuse the origin of variables if they share the same name.
  

src/mcp/transport.ts:9:8 lint/performance/noNamespaceImport ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Avoid namespace imports, it can prevent efficient tree shaking and increase bundle size.
  
     7 │ import { httpAddressToString, startHttpServer } from '../httpServer.js';
     8 │ import type { ServerBackendFactory } from './server.js';
   > 9 │ import * as mcpServer from './server.js';
       │        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    10 │ export async function start(
    11 │   serverBackendFactory: ServerBackendFactory,
  
  i Use named imports instead.
  

src/mcp/transport.ts:82:36 lint/nursery/noShadow ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This variable shadows another variable with the same name in the outer scope.
  
    80 │     const transport = new StreamableHTTPServerTransport({
    81 │       sessionIdGenerator: () => crypto.randomUUID(),
  > 82 │       onsessioninitialized: async (sessionId) => {
       │                                    ^^^^^^^^^
    83 │         testDebug(`create http session: ${transport.sessionId}`);
    84 │         await mcpServer.connect(serverBackendFactory, transport, true);
  
  i This is the shadowed variable, which is now inaccessible in the inner scope.
  
    67 │   sessions: Map<string, StreamableHTTPServerTransport>
    68 │ ) {
  > 69 │   const sessionId = req.headers['mcp-session-id'] as string | undefined;
       │         ^^^^^^^^^
    70 │   if (sessionId) {
    71 │     const transport = sessions.get(sessionId);
  
  i Consider renaming this variable. It's easy to confuse the origin of variables if they share the same name.
  

src/program.ts:20:8 lint/performance/noNamespaceImport ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Avoid namespace imports, it can prevent efficient tree shaking and increase bundle size.
  
    18 │ } from './extension/main.js';
    19 │ import { runLoopTools } from './loopTools/main.js';
  > 20 │ import * as mcpTransport from './mcp/transport.js';
       │        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    21 │ import { packageJSON } from './package.js';
    22 │ import { logServerStart } from './utils/requestLogger.js';
  
  i Use named imports instead.
  

src/response.ts:206:11 lint/complexity/noExcessiveCognitiveComplexity ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Excessive complexity of 16 detected (max: 15).
  
    204 │     return { content, isError: this._isError };
    205 │   }
  > 206 │   private renderFilteredTabSnapshot(tabSnapshot: TabSnapshot): string {
        │           ^^^^^^^^^^^^^^^^^^^^^^^^^
    207 │     const lines: string[] = [];
    208 │     const consoleOptions = this._expectation.consoleOptions;
  
  i Please refactor this function to reduce its complexity score from 16 to the max allowed complexity 15.
  

src/response.ts:338:17 lint/complexity/noExcessiveCognitiveComplexity ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Excessive complexity of 19 detected (max: 15).
  
    336 │    * Handles "Execution context was destroyed" errors gracefully
    337 │    */
  > 338 │   private async _captureSnapshotWithNavigationHandling(): Promise<void> {
        │                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    339 │     const currentTab = this._context.currentTabOrDie();
    340 │     const options = this._expectation.snapshotOptions;
  
  i Please refactor this function to reduce its complexity score from 19 to the max allowed complexity 15.
  

src/sessionLog.ts:103:3 lint/suspicious/useAwait ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This async function lacks an await expression.
  
    101 │     this._flushEntriesTimeout = setTimeout(() => this._flushEntries(), 1000);
    102 │   }
  > 103 │   private async _flushEntries() {
        │   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  > 104 │     clearTimeout(this._flushEntriesTimeout);
         ...
  > 157 │     );
  > 158 │   }
        │   ^
    159 │ }
    160 │ 
  
  i Remove this async modifier, or add an await expression in the function.
  
    101 │     this._flushEntriesTimeout = setTimeout(() => this._flushEntries(), 1000);
    102 │   }
  > 103 │   private async _flushEntries() {
        │   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  > 104 │     clearTimeout(this._flushEntriesTimeout);
         ...
  > 157 │     );
  > 158 │   }
        │   ^
    159 │ }
    160 │ 
  
  i Async functions without await expressions may not need to be declared async.
  

src/sessionLog.ts:103:17 lint/complexity/noExcessiveCognitiveComplexity ━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Excessive complexity of 16 detected (max: 15).
  
    101 │     this._flushEntriesTimeout = setTimeout(() => this._flushEntries(), 1000);
    102 │   }
  > 103 │   private async _flushEntries() {
        │                 ^^^^^^^^^^^^^
    104 │     clearTimeout(this._flushEntriesTimeout);
    105 │     const entries = this._pendingEntries;
  
  i Please refactor this function to reduce its complexity score from 16 to the max allowed complexity 15.
  

src/sessionLog.ts lint/style/useFilenamingConvention ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × The filename should be in kebab-case.
  
  i The filename could be renamed to one of the following names:
    session-log.ts
  

src/sessionLog.ts:65:5 lint/style/noParameterAssign ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Assigning a function parameter is confusing.
  
    63 │     isUpdate: boolean
    64 │   ) {
  > 65 │     code = code.trim();
       │     ^^^^
    66 │     if (isUpdate) {
    67 │       const lastEntry = this._pendingEntries.at(-1);
  
  i The parameter is declared here:
  
    60 │     action: actions.Action,
    61 │     tab: Tab,
  > 62 │     code: string,
       │     ^^^^
    63 │     isUpdate: boolean
    64 │   ) {
  
  i Developers usually expect function parameters to be readonly. To align with this expectation, use a local variable instead.
  

src/tab.ts:84:7 lint/complexity/noVoid ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × The use of void is not allowed.
  
    82 │     page.on('dialog', (dialog) => this._dialogShown(dialog));
    83 │     page.on('download', (download) => {
  > 84 │       void this._downloadStarted(download);
       │       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    85 │     });
    86 │ 
  
  i If you use void to alter the return type of a function or return `undefined`, use the global `undefined` instead.
  

src/tab.ts:543:16 lint/nursery/noShadow ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This variable shadows another variable with the same name in the outer scope.
  
    541 │   for (const state of modalStates) {
    542 │     const tool = context.tools
  > 543 │       .filter((tool) => 'clearsModalState' in tool)
        │                ^^^^
    544 │       .find((tool) => tool.clearsModalState === state.type);
    545 │     result.push(
  
  i This is the shadowed variable, which is now inaccessible in the inner scope.
  
    540 │   }
    541 │   for (const state of modalStates) {
  > 542 │     const tool = context.tools
        │           ^^^^
    543 │       .filter((tool) => 'clearsModalState' in tool)
    544 │       .find((tool) => tool.clearsModalState === state.type);
  
  i Consider renaming this variable. It's easy to confuse the origin of variables if they share the same name.
  

src/tab.ts:544:14 lint/nursery/noShadow ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This variable shadows another variable with the same name in the outer scope.
  
    542 │     const tool = context.tools
    543 │       .filter((tool) => 'clearsModalState' in tool)
  > 544 │       .find((tool) => tool.clearsModalState === state.type);
        │              ^^^^
    545 │     result.push(
    546 │       `- [${state.description}]: can be handled by the "${tool?.schema.name}" tool`
  
  i This is the shadowed variable, which is now inaccessible in the inner scope.
  
    540 │   }
    541 │   for (const state of modalStates) {
  > 542 │     const tool = context.tools
        │           ^^^^
    543 │       .filter((tool) => 'clearsModalState' in tool)
    544 │       .find((tool) => tool.clearsModalState === state.type);
  
  i Consider renaming this variable. It's easy to confuse the origin of variables if they share the same name.
  

src/tools/batchExecute.ts:13:66 lint/complexity/noExcessiveCognitiveComplexity ━━━━━━━━━━━━━━━━━━━━━

  × Excessive complexity of 35 detected (max: 15).
  
    11 │     type: 'destructive',
    12 │   },
  > 13 │   handle: async (context, params: BatchExecuteOptions, response) => {
       │                                                                  ^^^
    14 │     try {
    15 │       // Get or create batch executor from context
  
  i Please refactor this function to reduce its complexity score from 35 to the max allowed complexity 15.
  

src/tools/batchExecute.ts:39:19 lint/nursery/noShadow ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This variable shadows another variable with the same name in the outer scope.
  
    37 │           if (stepResult.success && stepResult.result) {
    38 │             // Add successful step content if available
  > 39 │             const result = stepResult.result as {
       │                   ^^^^^^
    40 │               content?: Array<{ text?: string }>;
    41 │             };
  
  i This is the shadowed variable, which is now inaccessible in the inner scope.
  
    22 │       }
    23 │       // Execute the batch
  > 24 │       const result: BatchResult = await batchExecutor.execute(params);
       │             ^^^^^^
    25 │       // Format and add result to response
    26 │       response.addResult(formatBatchResult(result));
  
  i Consider renaming this variable. It's easy to confuse the origin of variables if they share the same name.
  

src/tools/batchExecute.ts:88:9 lint/suspicious/noEvolvingTypes ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × The type of this variable may evolve implicitly to any type, including the any type.
  
    86 │  */
    87 │ function formatBatchResult(result: BatchResult): string {
  > 88 │   const lines = [];
       │         ^^^^^
    89 │   lines.push('### Batch Execution Summary');
    90 │   lines.push(`- Status: ${getStatusDisplay(result.stopReason)}`);
  
  i Add an explicit type or initialization to avoid implicit type evolution.
  

src/tools/batchExecute.ts lint/style/useFilenamingConvention ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × The filename should be in kebab-case.
  
  i The filename could be renamed to one of the following names:
    batch-execute.ts
  

src/tools/console.ts:13:11 lint/suspicious/useAwait ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This async function lacks an await expression.
  
    11 │     type: 'readOnly',
    12 │   },
  > 13 │   handle: async (tab, _params, response) => {
       │           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  > 14 │     const messages = tab.consoleMessages();
        ...
  > 21 │     }
  > 22 │   },
       │   ^
    23 │ });
    24 │ export default [console];
  
  i Remove this async modifier, or add an await expression in the function.
  
    11 │     type: 'readOnly',
    12 │   },
  > 13 │   handle: async (tab, _params, response) => {
       │           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  > 14 │     const messages = tab.consoleMessages();
        ...
  > 21 │     }
  > 22 │   },
       │   ^
    23 │ });
    24 │ export default [console];
  
  i Async functions without await expressions may not need to be declared async.
  

src/tools/diagnose.ts:602:17 lint/suspicious/noImplicitAnyLet ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This variable implicitly has the any type.
  
    600 │           try {
    601 │             // Get comprehensive performance metrics - use parallel analysis data if available
  > 602 │             let comprehensiveMetrics;
        │                 ^^^^^^^^^^^^^^^^^^^^
    603 │ 
    604 │             if (performanceMetrics) {
  
  i Variable declarations without type annotation and initialization implicitly have the any type. Declare a type or initialize the variable with some value.
  

src/tools/diagnose.ts:96:41 lint/complexity/noExcessiveCognitiveComplexity ━━━━━━━━━━━━━━━━━━━━━━━━━

  × Excessive complexity of 255 detected (max: 15).
  
    94 │     inputSchema: diagnoseSchema,
    95 │   },
  > 96 │   handle: async (tab, params, response) => {
       │                                         ^^^
    97 │     const {
    98 │       searchForElements,
  
  i Please refactor this function to reduce its complexity. It's currently too complex or too deeply nested to calculate an accurate score.
  

src/tools/diagnose.ts:386:25 lint/style/noNestedTernary ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Do not nest ternary expressions.
  
    384 │                   if (actual > 0) {
    385 │                     const performanceIndicator = deviation
  > 386 │                       ? deviation.significance === 'significant'
        │                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  > 387 │                         ? '🔴'
  > 388 │                         : deviation.significance === 'notable'
  > 389 │                           ? '🟡'
  > 390 │                           : '🟢'
        │                           ^^^^^^
    391 │                       : '⚪';
    392 │ 
  
  i Nesting ternary expressions can make code more difficult to understand.
  
  i Convert nested ternary expression into if-else statements or separate the conditions to make the logic easier to understand.
  

src/tools/diagnose.ts:388:27 lint/style/noNestedTernary ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Do not nest ternary expressions.
  
    386 │                       ? deviation.significance === 'significant'
    387 │                         ? '🔴'
  > 388 │                         : deviation.significance === 'notable'
        │                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  > 389 │                           ? '🟡'
  > 390 │                           : '🟢'
        │                           ^^^^^^
    391 │                       : '⚪';
    392 │ 
  
  i Nesting ternary expressions can make code more difficult to understand.
  
  i Convert nested ternary expression into if-else statements or separate the conditions to make the logic easier to understand.
  

src/tools/diagnose.ts:412:25 lint/style/noNestedTernary ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Do not nest ternary expressions.
  
    410 │                     override.impact === 'high'
    411 │                       ? '🔴'
  > 412 │                       : override.impact === 'medium'
        │                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  > 413 │                         ? '🟡'
  > 414 │                         : '🟢';
        │                         ^^^^^^
    415 │                   reportSections.push(
    416 │                     `  ${impactIcon} **${override.category}** (${override.impact} impact):`
  
  i Nesting ternary expressions can make code more difficult to understand.
  
  i Convert nested ternary expression into if-else statements or separate the conditions to make the logic easier to understand.
  

src/tools/diagnose.ts:436:27 lint/style/noNestedTernary ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Do not nest ternary expressions.
  
    434 │                       rec.type === 'warning'
    435 │                         ? '!�'
  > 436 │                         : rec.type === 'optimization'
        │                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  > 437 │                           ? '⚡'
  > 438 │                           : 'i�';
        │                           ^^^^^
    439 │                     reportSections.push(`  ${typeIcon} ${rec.message}`);
    440 │                   }
  
  i Nesting ternary expressions can make code more difficult to understand.
  
  i Convert nested ternary expression into if-else statements or separate the conditions to make the logic easier to understand.
  

src/tools/diagnose.ts:602:17 lint/suspicious/noEvolvingTypes ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × The type of this variable may evolve implicitly to any type, including the any type.
  
    600 │           try {
    601 │             // Get comprehensive performance metrics - use parallel analysis data if available
  > 602 │             let comprehensiveMetrics;
        │                 ^^^^^^^^^^^^^^^^^^^^
    603 │ 
    604 │             if (performanceMetrics) {
  
  i Add an explicit type or initialization to avoid implicit type evolution.
  

src/tools/evaluate.ts:3:8 lint/performance/noNamespaceImport ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Avoid namespace imports, it can prevent efficient tree shaking and increase bundle size.
  
    1 │ import type * as playwright from 'playwright';
    2 │ import { z } from 'zod';
  > 3 │ import * as javascript from '../javascript.js';
      │        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    4 │ import { expectationSchema } from '../schemas/expectation.js';
    5 │ import { defineTabTool } from './tool.js';
  
  i Use named imports instead.
  

src/tools/findElements.ts:67:41 lint/complexity/noExcessiveCognitiveComplexity ━━━━━━━━━━━━━━━━━━━━━

  × Excessive complexity of 54 detected (max: 15).
  
    65 │     inputSchema: findElementsSchema,
    66 │   },
  > 67 │   handle: async (tab, params, response) => {
       │                                         ^^^
    68 │     const {
    69 │       searchCriteria,
  
  i Please refactor this function to reduce its complexity score from 54 to the max allowed complexity 15.
  

src/tools/findElements.ts lint/style/useFilenamingConvention ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × The filename should be in kebab-case.
  
  i The filename could be renamed to one of the following names:
    find-elements.ts
  

src/tools/keyboard.ts:2:8 lint/performance/noNamespaceImport ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Avoid namespace imports, it can prevent efficient tree shaking and increase bundle size.
  
    1 │ import { z } from 'zod';
  > 2 │ import * as javascript from '../javascript.js';
      │        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    3 │ import { expectationSchema } from '../schemas/expectation.js';
    4 │ import { elementSchema } from './snapshot.js';
  
  i Use named imports instead.
  

src/tools/network.ts:14:11 lint/suspicious/useAwait ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This async function lacks an await expression.
  
    12 │     type: 'readOnly',
    13 │   },
  > 14 │   handle: async (tab, _params, response) => {
       │           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  > 15 │     const requests = tab.requests();
  > 16 │     for (const [req, res] of requests.entries()) {
  > 17 │       response.addResult(renderRequest(req, res));
  > 18 │     }
  > 19 │   },
       │   ^
    20 │ });
    21 │ function renderRequest(
  
  i Remove this async modifier, or add an await expression in the function.
  
    12 │     type: 'readOnly',
    13 │   },
  > 14 │   handle: async (tab, _params, response) => {
       │           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  > 15 │     const requests = tab.requests();
  > 16 │     for (const [req, res] of requests.entries()) {
  > 17 │       response.addResult(renderRequest(req, res));
  > 18 │     }
  > 19 │   },
       │   ^
    20 │ });
    21 │ function renderRequest(
  
  i Async functions without await expressions may not need to be declared async.
  

src/tools/network.ts:15:11 lint/nursery/noShadow ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This variable shadows another variable with the same name in the outer scope.
  
    13 │   },
    14 │   handle: async (tab, _params, response) => {
  > 15 │     const requests = tab.requests();
       │           ^^^^^^^^
    16 │     for (const [req, res] of requests.entries()) {
    17 │       response.addResult(renderRequest(req, res));
  
  i This is the shadowed variable, which is now inaccessible in the inner scope.
  
    3 │ import { defineTabTool } from './tool.js';
    4 │ 
  > 5 │ const requests = defineTabTool({
      │       ^^^^^^^^
    6 │   capability: 'core',
    7 │   schema: {
  
  i Consider renaming this variable. It's easy to confuse the origin of variables if they share the same name.
  

src/tools/pdf.ts:2:8 lint/performance/noNamespaceImport ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Avoid namespace imports, it can prevent efficient tree shaking and increase bundle size.
  
    1 │ import { z } from 'zod';
  > 2 │ import * as javascript from '../javascript.js';
      │        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    3 │ import { defineTabTool } from './tool.js';
    4 │ 
  
  i Use named imports instead.
  

src/tools/screenshot.ts:3:8 lint/performance/noNamespaceImport ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Avoid namespace imports, it can prevent efficient tree shaking and increase bundle size.
  
    1 │ import type * as playwright from 'playwright';
    2 │ import { z } from 'zod';
  > 3 │ import * as javascript from '../javascript.js';
      │        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    4 │ import { expectationSchema } from '../schemas/expectation.js';
    5 │ import { defineTabTool } from './tool.js';
  
  i Use named imports instead.
  

src/tools/screenshot.ts:82:9 lint/style/noNestedTernary ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Do not nest ternary expressions.
  
    80 │     const screenshotTarget = isElementScreenshot
    81 │       ? params.element
  > 82 │       : params.fullPage
       │         ^^^^^^^^^^^^^^^
  > 83 │         ? 'full page'
  > 84 │         : 'viewport';
       │         ^^^^^^^^^^^^
    85 │     response.addCode(
    86 │       `// Screenshot ${screenshotTarget} and save it as ${fileName}`
  
  i Nesting ternary expressions can make code more difficult to understand.
  
  i Convert nested ternary expression into if-else statements or separate the conditions to make the logic easier to understand.
  

src/tools/screenshot.ts:90:41 lint/style/noNonNullAssertion ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Forbidden non-null assertion.
  
    88 │     // Only get snapshot when element screenshot is needed
    89 │     const locator = isElementScreenshot
  > 90 │       ? await tab.refLocator({ element: params.element!, ref: params.ref! })
       │                                         ^^^^^^^^^^^^^^^
    91 │       : null;
    92 │     if (locator) {
  

src/tools/screenshot.ts:90:63 lint/style/noNonNullAssertion ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Forbidden non-null assertion.
  
    88 │     // Only get snapshot when element screenshot is needed
    89 │     const locator = isElementScreenshot
  > 90 │       ? await tab.refLocator({ element: params.element!, ref: params.ref! })
       │                                                               ^^^^^^^^^^^
    91 │       : null;
    92 │     if (locator) {
  

src/tools/snapshot.ts:2:8 lint/performance/noNamespaceImport ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Avoid namespace imports, it can prevent efficient tree shaking and increase bundle size.
  
    1 │ import { z } from 'zod';
  > 2 │ import * as javascript from '../javascript.js';
      │        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    3 │ import { expectationSchema } from '../schemas/expectation.js';
    4 │ import { defineTabTool, defineTool } from './tool.js';
  
  i Use named imports instead.
  

src/tools/snapshot.ts:28:13 lint/nursery/noShadow ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This variable shadows another variable with the same name in the outer scope.
  
    26 │       const options = params.expectation.snapshotOptions;
    27 │       // Manually capture partial snapshot and store it
  > 28 │       const snapshot = await tab.capturePartialSnapshot(
       │             ^^^^^^^^
    29 │         options.selector,
    30 │         options.maxLength
  
  i This is the shadowed variable, which is now inaccessible in the inner scope.
  
    5 │ import { generateLocator } from './utils.js';
    6 │ 
  > 7 │ const snapshot = defineTool({
      │       ^^^^^^^^
    8 │   capability: 'core',
    9 │   schema: {
  
  i Consider renaming this variable. It's easy to confuse the origin of variables if they share the same name.
  

src/tools/tool.ts:48:13 lint/suspicious/useAwait ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This async function lacks an await expression.
  
    46 │   return {
    47 │     ...tool,
  > 48 │     handle: async (context, params, response) => {
       │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  > 49 │       const tab = context.currentTabOrDie();
        ...
  > 66 │       }
  > 67 │     },
       │     ^
    68 │   };
    69 │ }
  
  i Remove this async modifier, or add an await expression in the function.
  
    46 │   return {
    47 │     ...tool,
  > 48 │     handle: async (context, params, response) => {
       │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  > 49 │       const tab = context.currentTabOrDie();
        ...
  > 66 │       }
  > 67 │     },
       │     ^
    68 │   };
    69 │ }
  
  i Async functions without await expressions may not need to be declared async.
  

src/tools/utils.ts:33:5 lint/complexity/noVoid ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × The use of void is not allowed.
  
    32 │     // Enhanced navigation handling with stability checks
  > 33 │     void (async () => {
       │     ^^^^^^^^^^^^^^^^^^^
  > 34 │       try {
        ...
  > 51 │       }
  > 52 │     })();
       │     ^^^^
    53 │   };
    54 │   const onTimeout = () => {
  
  i If you use void to alter the return type of a function or return `undefined`, use the global `undefined` instead.
  

src/tools/utils.ts:114:14 lint/nursery/noShadow ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This variable shadows another variable with the same name in the outer scope.
  
    112 │ export async function callOnPageNoTrace<T>(
    113 │   page: playwright.Page,
  > 114 │   callback: (page: playwright.Page) => Promise<T>
        │              ^^^^
    115 │ ): Promise<T> {
    116 │   return await (
  
  i This is the shadowed variable, which is now inaccessible in the inner scope.
  
    111 │ }
    112 │ export async function callOnPageNoTrace<T>(
  > 113 │   page: playwright.Page,
        │   ^^^^
    114 │   callback: (page: playwright.Page) => Promise<T>
    115 │ ): Promise<T> {
  
  i Consider renaming this variable. It's easy to confuse the origin of variables if they share the same name.
  

src/tools/wait.ts:29:49 lint/style/noNonNullAssertion ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Forbidden non-null assertion.
  
    27 │     if (params.time) {
    28 │       code.push(
  > 29 │         `await new Promise(f => setTimeout(f, ${params.time!} * 1000));`
       │                                                 ^^^^^^^^^^^^
    30 │       );
    31 │       await new Promise((f) =>
  

src/tools/wait.ts:32:40 lint/style/noNonNullAssertion ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Forbidden non-null assertion.
  
    30 │       );
    31 │       await new Promise((f) =>
  > 32 │         setTimeout(f, Math.min(30_000, params.time! * 1000))
       │                                        ^^^^^^^^^^^^
    33 │       );
    34 │     }
  

src/utils.ts:7:17 lint/suspicious/noControlCharactersInRegex ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Unexpected control character in a regular expression.
  
    5 │ export function sanitizeForFilePath(s: string) {
    6 │   const sanitize = (s: string) =>
  > 7 │     s.replace(/[\x00-\x2C\x2E-\x2F\x3A-\x40\x5B-\x60\x7B-\x7F]+/g, '-');
      │                 ^^^^
    8 │   const separator = s.lastIndexOf('.');
    9 │   if (separator === -1) {
  
  i Control characters are unusual and potentially incorrect inputs, so they are disallowed.
  

src/utils.ts:6:21 lint/nursery/noShadow ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This variable shadows another variable with the same name in the outer scope.
  
    4 │ }
    5 │ export function sanitizeForFilePath(s: string) {
  > 6 │   const sanitize = (s: string) =>
      │                     ^
    7 │     s.replace(/[\x00-\x2C\x2E-\x2F\x3A-\x40\x5B-\x60\x7B-\x7F]+/g, '-');
    8 │   const separator = s.lastIndexOf('.');
  
  i This is the shadowed variable, which is now inaccessible in the inner scope.
  
    3 │   return crypto.createHash('sha256').update(data).digest('hex').slice(0, 7);
    4 │ }
  > 5 │ export function sanitizeForFilePath(s: string) {
      │                                     ^
    6 │   const sanitize = (s: string) =>
    7 │     s.replace(/[\x00-\x2C\x2E-\x2F\x3A-\x40\x5B-\x60\x7B-\x7F]+/g, '-');
  
  i Consider renaming this variable. It's easy to confuse the origin of variables if they share the same name.
  

src/utils/consoleFilter.ts lint/style/useFilenamingConvention ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × The filename should be in kebab-case.
  
  i The filename could be renamed to one of the following names:
    console-filter.ts
  

src/utils/diffFormatter.ts:15:3 lint/complexity/noExcessiveCognitiveComplexity ━━━━━━━━━━━━━━━━━━━━━

  × Excessive complexity of 33 detected (max: 15).
  
    13 │    * @returns Formatted diff string
    14 │    */
  > 15 │   formatUnified(segments: DiffSegment[], context = 3): string {
       │   ^^^^^^^^^^^^^
    16 │     if (segments.length === 0) {
    17 │       return '';
  
  i Please refactor this function to reduce its complexity score from 33 to the max allowed complexity 15.
  

src/utils/diffFormatter.ts:60:3 lint/complexity/noExcessiveCognitiveComplexity ━━━━━━━━━━━━━━━━━━━━━

  × Excessive complexity of 29 detected (max: 15).
  
    58 │    * @returns Formatted diff string
    59 │    */
  > 60 │   formatSplit(segments: DiffSegment[]): string {
       │   ^^^^^^^^^^^
    61 │     const removedLines: string[] = [];
    62 │     const addedLines: string[] = [];
  
  i Please refactor this function to reduce its complexity score from 29 to the max allowed complexity 15.
  

src/utils/diffFormatter.ts lint/style/useFilenamingConvention ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × The filename should be in kebab-case.
  
  i The filename could be renamed to one of the following names:
    diff-formatter.ts
  

src/utils/imageProcessor.ts:33:23 lint/complexity/noExcessiveCognitiveComplexity ━━━━━━━━━━━━━━━━━━━

  × Excessive complexity of 26 detected (max: 15).
  
    31 │  * Process image using Sharp library
    32 │  */
  > 33 │ export async function processImage(
       │                       ^^^^^^^^^^^^
    34 │   imageData: Buffer,
    35 │   originalContentType: string,
  
  i Please refactor this function to reduce its complexity score from 26 to the max allowed complexity 15.
  

src/utils/imageProcessor.ts lint/style/useFilenamingConvention ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × The filename should be in kebab-case.
  
  i The filename could be renamed to one of the following names:
    image-processor.ts
  

src/utils/requestLogger.ts lint/style/useFilenamingConvention ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × The filename should be in kebab-case.
  
  i The filename could be renamed to one of the following names:
    request-logger.ts
  

src/utils/responseDiffDetector.ts:27:3 lint/suspicious/useAwait ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This async function lacks an await expression.
  
     25 │    * @returns Diff result with formatted differences
     26 │    */
   > 27 │   async detectDiff(
        │   ^^^^^^^^^^^^^^^^^
   > 28 │     current: string,
         ...
  > 108 │     };
  > 109 │   }
        │   ^
    110 │ 
    111 │   /**
  
  i Remove this async modifier, or add an await expression in the function.
  
     25 │    * @returns Diff result with formatted differences
     26 │    */
   > 27 │   async detectDiff(
        │   ^^^^^^^^^^^^^^^^^
   > 28 │     current: string,
         ...
  > 108 │     };
  > 109 │   }
        │   ^
    110 │ 
    111 │   /**
  
  i Async functions without await expressions may not need to be declared async.
  

src/utils/responseDiffDetector.ts:76:7 lint/style/useDefaultSwitchClause ━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Expected a default switch clause.
  
    75 │       // Format the diff based on requested format
  > 76 │       switch (options.format) {
       │       ^^^^^^^^^^^^^^^^^^^^^^^^^
  > 77 │         case 'unified':
        ...
  > 88 │           break;
  > 89 │       }
       │       ^
    90 │ 
    91 │       // Limit output size
  
  i The lack of a default clause can be a possible omission.
  
  i Consider adding a default clause.
  

src/utils/responseDiffDetector.ts:145:38 lint/style/noNestedTernary ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Do not nest ternary expressions.
  
    143 │     const result = diff(oldText, newText);
    144 │     return result.map(([type, value]) => ({
  > 145 │       type: type === -1 ? 'remove' : type === 1 ? 'add' : 'equal',
        │                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    146 │       value,
    147 │     }));
  
  i Nesting ternary expressions can make code more difficult to understand.
  
  i Convert nested ternary expression into if-else statements or separate the conditions to make the logic easier to understand.
  

src/utils/responseDiffDetector.ts lint/style/useFilenamingConvention ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × The filename should be in kebab-case.
  
  i The filename could be renamed to one of the following names:
    response-diff-detector.ts
  

tests/batch-execute-basic.spec.ts:108:44 lint/performance/useTopLevelRegex ━━━━━━━━━━━━━━━━━━━━━━━━━

  × This regex literal is not defined in the top level scope. This can lead to performance issues if this function is called frequently.
  
    106 │     expect(result.content[0].text).toContain('✅ Completed');
    107 │     expect(result.content[0].text).toContain('Total Time:');
  > 108 │     expect(result.content[0].text).toMatch(/\d+ms/); // Should contain execution time in milliseconds
        │                                            ^^^^^^^
    109 │   });
    110 │ });
  
  i Move the regex literal outside of this scope, and place it at the top level of this module, as a constant.
  

tests/batch-execute.spec.ts:299:44 lint/performance/useTopLevelRegex ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This regex literal is not defined in the top level scope. This can lead to performance issues if this function is called frequently.
  
    297 │     expect(result.content[0].text).toContain('Total Steps: 2');
    298 │     expect(result.content[0].text).toContain('Total Time:');
  > 299 │     expect(result.content[0].text).toMatch(/\d+ms/); // Should contain execution time in milliseconds
        │                                            ^^^^^^^
    300 │   });
    301 │ 
  
  i Move the regex literal outside of this scope, and place it at the top level of this module, as a constant.
  

tests/cdp.spec.ts:120:35 lint/suspicious/useAwait ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This async function lacks an await expression.
  
    118 │ const __filename = url.fileURLToPath(import.meta.url);
    119 │ 
  > 120 │ test('does not support --device', async () => {
        │                                   ^^^^^^^^^^^^^
  > 121 │   const result = spawnSync('node', [
         ...
  > 129 │     'Device emulation is not supported with cdpEndpoint.'
  > 130 │   );
  > 131 │ });
        │ ^
    132 │ 
  
  i Remove this async modifier, or add an await expression in the function.
  
    118 │ const __filename = url.fileURLToPath(import.meta.url);
    119 │ 
  > 120 │ test('does not support --device', async () => {
        │                                   ^^^^^^^^^^^^^
  > 121 │   const result = spawnSync('node', [
         ...
  > 129 │     'Device emulation is not supported with cdpEndpoint.'
  > 130 │   );
  > 131 │ });
        │ ^
    132 │ 
  
  i Async functions without await expressions may not need to be declared async.
  

tests/config.spec.ts:25:3 lint/correctness/noUnusedFunctionParameters ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This parameter is unused.
  
    23 │   startClient,
    24 │   server,
  > 25 │   mcpMode,
       │   ^^^^^^^
    26 │ }, testInfo) => {
    27 │   server.setContent(
  
  i Unused parameters might be the result of an incomplete refactoring.
  

tests/config.spec.ts:68:27 lint/correctness/noUnusedFunctionParameters ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This parameter is unused.
  
    66 │       },
    67 │     },
  > 68 │     async ({ startClient, mcpMode }, testInfo) => {
       │                           ^^^^^^^
    69 │       const config: Config = {
    70 │         browser: {
  
  i Unused parameters might be the result of an incomplete refactoring.
  

tests/config.spec.ts:54:43 lint/style/noNonNullAssertion ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Forbidden non-null assertion.
  
    52 │   });
    53 │ 
  > 54 │   const files = await fs.promises.readdir(config.browser?.userDataDir!);
       │                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    55 │   expect(files.length).toBeGreaterThan(0);
    56 │ });
  

tests/console-filtering.spec.ts:139:60 lint/style/noNonNullAssertion ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Forbidden non-null assertion.
  
    138 │     expect(result.length).toBeLessThanOrEqual(2);
  > 139 │     expect(result.every((msg) => ['log', 'error'].includes(msg.type!))).toBe(
        │                                                            ^^^^^^^^^
    140 │       true
    141 │     );
  

tests/device.spec.ts:19:60 lint/correctness/noUnusedFunctionParameters ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This parameter is unused.
  
    17 │ import { expect, test } from './fixtures.js';
    18 │ 
  > 19 │ test('--device should work', async ({ startClient, server, mcpMode }) => {
       │                                                            ^^^^^^^
    20 │   const { client } = await startClient({
    21 │     args: ['--device', 'iPhone 15'],
  
  i Unused parameters might be the result of an incomplete refactoring.
  

tests/diagnostic-system.spec.ts:961:59 lint/nursery/noShadow ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This variable shadows another variable with the same name in the outer scope.
  
    959 │               <input type="text" id="input-${i}" data-value="${i}" placeholder="Enter ${i}">
    960 │               <select name="select-${i}">
  > 961 │                 ${Array.from({ length: complexity + 2 }, (_, j) => `<option value="${j}">Option ${j}</option>`).join('')}
        │                                                           ^
    962 │               </select>
    963 │               <img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCI+PC9zdmc+" alt="Image ${i}">
  
  i This is the shadowed variable, which is now inaccessible in the inner scope.
  
    953 │         <body>
    954 │           ${Array.from({ length: 3 }, (_, i) => `<iframe src="data:text/html,<h1>Frame ${i}</h1>"></iframe>`).join('')}
  > 955 │           ${Array.from({ length: 1200 }, (_, i) => {
        │                                           ^
    956 │             const complexity = i % 5;
    957 │             return `<div class="level-${complexity}">
  
  i Consider renaming this variable. It's easy to confuse the origin of variables if they share the same name.
  

tests/diagnostic-system.spec.ts:975:20 lint/suspicious/noExplicitAny ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Unexpected any. Specify a different type.
  
    973 │     // Run multiple analysis to test consistency
    974 │     const times: number[] = [];
  > 975 │     const results: any[] = [];
        │                    ^^^
    976 │ 
    977 │     for (let i = 0; i < 3; i++) {
  
  i any disables many type checking rules. Its use should be avoided.
  

tests/diagnostic-system.spec.ts:979:22 lint/nursery/noAwaitInLoop ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Avoid using await inside loops.
  
    977 │     for (let i = 0; i < 3; i++) {
    978 │       const start = Date.now();
  > 979 │       const result = await pageAnalyzer.runParallelAnalysis();
        │                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    980 │       const time = Date.now() - start;
    981 │ 
  
  i Using await inside loops might cause performance issues or unintended sequential execution, consider use Promise.all() instead.
  

tests/diagnostic-system.spec.ts:1138:22 lint/suspicious/noExplicitAny ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Unexpected any. Specify a different type.
  
    1137 │     await browserDiagnose.handle(
  > 1138 │       mockContext as any,
         │                      ^^^
    1139 │       params,
    1140 │       mockResponse as any
  
  i any disables many type checking rules. Its use should be avoided.
  

tests/diagnostic-system.spec.ts:1140:23 lint/suspicious/noExplicitAny ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Unexpected any. Specify a different type.
  
    1138 │       mockContext as any,
    1139 │       params,
  > 1140 │       mockResponse as any
         │                       ^^^
    1141 │     );
    1142 │ 
  
  i any disables many type checking rules. Its use should be avoided.
  

tests/diagnostic-system.spec.ts:1150:28 lint/performance/useTopLevelRegex ━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This regex literal is not defined in the top level scope. This can lead to performance issues if this function is called frequently.
  
    1148 │     expect(report).toContain('Performance Thresholds:');
    1149 │     // Check for actual threshold values reported in the format: oldValue → newValue
  > 1150 │     expect(report).toMatch(/1000ms → 2000ms|Page Analysis:.*2000ms/);
         │                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    1151 │     expect(report).toMatch(/500ms → 1500ms|Element Discovery:.*1500ms/);
    1152 │   });
  
  i Move the regex literal outside of this scope, and place it at the top level of this module, as a constant.
  

tests/diagnostic-system.spec.ts:1151:28 lint/performance/useTopLevelRegex ━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This regex literal is not defined in the top level scope. This can lead to performance issues if this function is called frequently.
  
    1149 │     // Check for actual threshold values reported in the format: oldValue → newValue
    1150 │     expect(report).toMatch(/1000ms → 2000ms|Page Analysis:.*2000ms/);
  > 1151 │     expect(report).toMatch(/500ms → 1500ms|Element Discovery:.*1500ms/);
         │                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    1152 │   });
    1153 │ 
  
  i Move the regex literal outside of this scope, and place it at the top level of this module, as a constant.
  

tests/diagnostic-system.spec.ts:1212:22 lint/suspicious/noExplicitAny ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Unexpected any. Specify a different type.
  
    1211 │     await browserDiagnose.handle(
  > 1212 │       mockContext as any,
         │                      ^^^
    1213 │       paramsWithout,
    1214 │       mockResponseWithout as any
  
  i any disables many type checking rules. Its use should be avoided.
  

tests/diagnostic-system.spec.ts:1214:30 lint/suspicious/noExplicitAny ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Unexpected any. Specify a different type.
  
    1212 │       mockContext as any,
    1213 │       paramsWithout,
  > 1214 │       mockResponseWithout as any
         │                              ^^^
    1215 │     );
    1216 │     await browserDiagnose.handle(
  
  i any disables many type checking rules. Its use should be avoided.
  

tests/diagnostic-system.spec.ts:1217:22 lint/suspicious/noExplicitAny ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Unexpected any. Specify a different type.
  
    1215 │     );
    1216 │     await browserDiagnose.handle(
  > 1217 │       mockContext as any,
         │                      ^^^
    1218 │       paramsWith,
    1219 │       mockResponseWith as any
  
  i any disables many type checking rules. Its use should be avoided.
  

tests/diagnostic-system.spec.ts:1219:27 lint/suspicious/noExplicitAny ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Unexpected any. Specify a different type.
  
    1217 │       mockContext as any,
    1218 │       paramsWith,
  > 1219 │       mockResponseWith as any
         │                           ^^^
    1220 │     );
    1221 │ 
  
  i any disables many type checking rules. Its use should be avoided.
  

tests/diagnostic-system.spec.ts:1278:22 lint/suspicious/noExplicitAny ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Unexpected any. Specify a different type.
  
    1277 │     await browserDiagnose.handle(
  > 1278 │       mockContext as any,
         │                      ^^^
    1279 │       params,
    1280 │       mockResponse as any
  
  i any disables many type checking rules. Its use should be avoided.
  

tests/diagnostic-system.spec.ts:1280:23 lint/suspicious/noExplicitAny ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Unexpected any. Specify a different type.
  
    1278 │       mockContext as any,
    1279 │       params,
  > 1280 │       mockResponse as any
         │                       ^^^
    1281 │     );
    1282 │ 
  
  i any disables many type checking rules. Its use should be avoided.
  

tests/diagnostic-system.spec.ts:1291:28 lint/performance/useTopLevelRegex ━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This regex literal is not defined in the top level scope. This can lead to performance issues if this function is called frequently.
  
    1289 │     // Check for performance baseline comparison instead of applied changes
    1290 │     expect(report).toContain('**Performance Baseline Comparison:**');
  > 1291 │     expect(report).toMatch(/pageAnalysis.*Expected.*5000ms/);
         │                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    1292 │   });
    1293 │ });
  
  i Move the regex literal outside of this scope, and place it at the top level of this module, as a constant.
  

tests/element-discovery-error-handling.spec.ts:98:20 lint/suspicious/useAwait ━━━━━━━━━━━━━━━━━━━━━━

  × This async function lacks an await expression.
  
     96 │         throw new Error('Network connection lost');
     97 │       },
   > 98 │       textContent: async () => {
        │                    ^^^^^^^^^^^^^
   > 99 │         throw new Error('Element detached from DOM');
  > 100 │       },
        │       ^
    101 │       getAttribute: async () => null,
    102 │       evaluate: async () => 'failed-selector',
  
  i Remove this async modifier, or add an await expression in the function.
  
     96 │         throw new Error('Network connection lost');
     97 │       },
   > 98 │       textContent: async () => {
        │                    ^^^^^^^^^^^^^
   > 99 │         throw new Error('Element detached from DOM');
  > 100 │       },
        │       ^
    101 │       getAttribute: async () => null,
    102 │       evaluate: async () => 'failed-selector',
  
  i Async functions without await expressions may not need to be declared async.
  

tests/element-discovery-error-handling.spec.ts:125:16 lint/suspicious/useAwait ━━━━━━━━━━━━━━━━━━━━━

  × This async function lacks an await expression.
  
    124 │     const mockElement = {
  > 125 │       dispose: async () => {
        │                ^^^^^^^^^^^^^
  > 126 │         disposeCallCount++;
  > 127 │         throw new Error('Dispose fails every time');
  > 128 │       },
        │       ^
    129 │     };
    130 │ 
  
  i Remove this async modifier, or add an await expression in the function.
  
    124 │     const mockElement = {
  > 125 │       dispose: async () => {
        │                ^^^^^^^^^^^^^
  > 126 │         disposeCallCount++;
  > 127 │         throw new Error('Dispose fails every time');
  > 128 │       },
        │       ^
    129 │     };
    130 │ 
  
  i Async functions without await expressions may not need to be declared async.
  

tests/element-discovery-error-handling.spec.ts:151:82 lint/suspicious/useAwait ━━━━━━━━━━━━━━━━━━━━━

  × This async function lacks an await expression.
  
    149 │   });
    150 │ 
  > 151 │   test('should create properly structured DiagnosticError for dispose failures', async () => {
        │                                                                                  ^^^^^^^^^^^^^
  > 152 │     const originalError = new Error('Element handle is invalid');
         ...
  > 172 │     );
  > 173 │   });
        │   ^
    174 │ 
    175 │   test('should handle memory pressure scenarios during dispose', async () => {
  
  i Remove this async modifier, or add an await expression in the function.
  
    149 │   });
    150 │ 
  > 151 │   test('should create properly structured DiagnosticError for dispose failures', async () => {
        │                                                                                  ^^^^^^^^^^^^^
  > 152 │     const originalError = new Error('Element handle is invalid');
         ...
  > 172 │     );
  > 173 │   });
        │   ^
    174 │ 
    175 │   test('should handle memory pressure scenarios during dispose', async () => {
  
  i Async functions without await expressions may not need to be declared async.
  

tests/element-discovery-error-handling.spec.ts:179:16 lint/suspicious/useAwait ━━━━━━━━━━━━━━━━━━━━━

  × This async function lacks an await expression.
  
    178 │     const mockElement = {
  > 179 │       dispose: async () => {
        │                ^^^^^^^^^^^^^
  > 180 │         memoryUsage += 30 * 1024 * 1024; // Exceed limit by 30MB
         ...
  > 187 │         );
  > 188 │       },
        │       ^
    189 │     };
    190 │ 
  
  i Remove this async modifier, or add an await expression in the function.
  
    178 │     const mockElement = {
  > 179 │       dispose: async () => {
        │                ^^^^^^^^^^^^^
  > 180 │         memoryUsage += 30 * 1024 * 1024; // Exceed limit by 30MB
         ...
  > 187 │         );
  > 188 │       },
        │       ^
    189 │     };
    190 │ 
  
  i Async functions without await expressions may not need to be declared async.
  

tests/element-discovery-error-handling.spec.ts:95:16 lint/suspicious/useAwait ━━━━━━━━━━━━━━━━━━━━━━

  × This async function lacks an await expression.
  
    93 │     // Create mock element with multiple failure scenarios
    94 │     const failingElement = {
  > 95 │       dispose: async () => {
       │                ^^^^^^^^^^^^^
  > 96 │         throw new Error('Network connection lost');
  > 97 │       },
       │       ^
    98 │       textContent: async () => {
    99 │         throw new Error('Element detached from DOM');
  
  i Remove this async modifier, or add an await expression in the function.
  
    93 │     // Create mock element with multiple failure scenarios
    94 │     const failingElement = {
  > 95 │       dispose: async () => {
       │                ^^^^^^^^^^^^^
  > 96 │         throw new Error('Network connection lost');
  > 97 │       },
       │       ^
    98 │       textContent: async () => {
    99 │         throw new Error('Element detached from DOM');
  
  i Async functions without await expressions may not need to be declared async.
  

tests/evaluate.spec.ts:91:29 lint/performance/useTopLevelRegex ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This regex literal is not defined in the top level scope. This can lead to performance issues if this function is called frequently.
  
    89 │   // Check for common error patterns across browsers
    90 │   const errorText = result.content?.[0]?.text || '';
  > 91 │   expect(errorText).toMatch(/not defined|Can't find variable/);
       │                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    92 │ });
    93 │ 
  
  i Move the regex literal outside of this scope, and place it at the top level of this module, as a constant.
  

tests/files.spec.ts:165:3 lint/correctness/noUnusedFunctionParameters ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This parameter is unused.
  
    163 │   server,
    164 │   mcpBrowser,
  > 165 │   mcpMode,
        │   ^^^^^^^
    166 │ }, testInfo) => {
    167 │   const { client } = await startClient({
  
  i Unused parameters might be the result of an incomplete refactoring.
  

tests/files.spec.ts:119:3 lint/correctness/noUnusedFunctionParameters ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This parameter is unused.
  
    117 │   startClient,
    118 │   server,
  > 119 │   mcpMode,
        │   ^^^^^^^
    120 │ }, testInfo) => {
    121 │   const { client } = await startClient({
  
  i Unused parameters might be the result of an incomplete refactoring.
  

tests/fixtures.ts:66:25 lint/suspicious/useAwait ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This async function lacks an await expression.
  
    64 │       // Wrap callTool to add default expectations for tests
    65 │       const originalCallTool = client.callTool.bind(client);
  > 66 │       client.callTool = async (request: any) => {
       │                         ^^^^^^^^^^^^^^^^^^^^^^^^^
  > 67 │         // Add default expectation for tests if not specified
        ...
  > 90 │         return originalCallTool(request);
  > 91 │       };
       │       ^
    92 │       await use(client);
    93 │     },
  
  i Remove this async modifier, or add an await expression in the function.
  
    64 │       // Wrap callTool to add default expectations for tests
    65 │       const originalCallTool = client.callTool.bind(client);
  > 66 │       client.callTool = async (request: any) => {
       │                         ^^^^^^^^^^^^^^^^^^^^^^^^^
  > 67 │         // Add default expectation for tests if not specified
        ...
  > 90 │         return originalCallTool(request);
  > 91 │       };
       │       ^
    92 │       await use(client);
    93 │     },
  
  i Async functions without await expressions may not need to be declared async.
  

tests/fixtures.ts:66:41 lint/suspicious/noExplicitAny ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Unexpected any. Specify a different type.
  
    64 │       // Wrap callTool to add default expectations for tests
    65 │       const originalCallTool = client.callTool.bind(client);
  > 66 │       client.callTool = async (request: any) => {
       │                                         ^^^
    67 │         // Add default expectation for tests if not specified
    68 │         if (request.arguments && !request.arguments.expectation) {
  
  i any disables many type checking rules. Its use should be avoided.
  

tests/fixtures.ts:100:38 lint/style/noNonNullAssertion ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Forbidden non-null assertion.
  
     98 │       testInfo
     99 │     ) => {
  > 100 │       const configDir = path.dirname(test.info().config.configFile!);
        │                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    101 │       let client: Client | undefined;
    102 │ 
  

tests/fixtures.ts:103:33 lint/complexity/noExcessiveCognitiveComplexity ━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Excessive complexity of 16 detected (max: 15).
  
    101 │       let client: Client | undefined;
    102 │ 
  > 103 │       await use(async (options) => {
        │                                 ^^^
    104 │         const args: string[] = [];
    105 │         if (process.env.CI && process.platform === 'linux') {
  
  i Please refactor this function to reduce its complexity score from 16 to the max allowed complexity 15.
  

tests/fixtures.ts:131:60 lint/suspicious/useAwait ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This async function lacks an await expression.
  
    129 │         );
    130 │         if (options?.roots) {
  > 131 │           client.setRequestHandler(ListRootsRequestSchema, async (_request) => {
        │                                                            ^^^^^^^^^^^^^^^^^^^^^
  > 132 │             return {
  > 133 │               roots: options.roots,
  > 134 │             };
  > 135 │           });
        │           ^
    136 │         }
    137 │         const { transport, stderr } = await createTransport(
  
  i Remove this async modifier, or add an await expression in the function.
  
    129 │         );
    130 │         if (options?.roots) {
  > 131 │           client.setRequestHandler(ListRootsRequestSchema, async (_request) => {
        │                                                            ^^^^^^^^^^^^^^^^^^^^^
  > 132 │             return {
  > 133 │               roots: options.roots,
  > 134 │             };
  > 135 │           });
        │           ^
    136 │         }
    137 │         const { transport, stderr } = await createTransport(
  
  i Async functions without await expressions may not need to be declared async.
  

tests/fixtures.ts:154:27 lint/suspicious/useAwait ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This async function lacks an await expression.
  
    152 │         // Wrap callTool to add default expectations for tests
    153 │         const originalCallTool = client.callTool.bind(client);
  > 154 │         client.callTool = async (request: any) => {
        │                           ^^^^^^^^^^^^^^^^^^^^^^^^^
  > 155 │           // Add default expectation for tests if not specified
         ...
  > 178 │           return originalCallTool(request);
  > 179 │         };
        │         ^
    180 │ 
    181 │         return { client, stderr: () => stderrBuffer };
  
  i Remove this async modifier, or add an await expression in the function.
  
    152 │         // Wrap callTool to add default expectations for tests
    153 │         const originalCallTool = client.callTool.bind(client);
  > 154 │         client.callTool = async (request: any) => {
        │                           ^^^^^^^^^^^^^^^^^^^^^^^^^
  > 155 │           // Add default expectation for tests if not specified
         ...
  > 178 │           return originalCallTool(request);
  > 179 │         };
        │         ^
    180 │ 
    181 │         return { client, stderr: () => stderrBuffer };
  
  i Async functions without await expressions may not need to be declared async.
  

tests/fixtures.ts:154:43 lint/suspicious/noExplicitAny ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Unexpected any. Specify a different type.
  
    152 │         // Wrap callTool to add default expectations for tests
    153 │         const originalCallTool = client.callTool.bind(client);
  > 154 │         client.callTool = async (request: any) => {
        │                                           ^^^
    155 │           // Add default expectation for tests if not specified
    156 │           if (request.arguments && !request.arguments.expectation) {
  
  i any disables many type checking rules. Its use should be avoided.
  

tests/fixtures.ts:187:24 lint/correctness/noEmptyPattern ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Unexpected empty object pattern.
  
    185 │     },
    186 │ 
  > 187 │     wsEndpoint: async ({}, use) => {
        │                        ^^
    188 │       const browserServer = await chromium.launchServer();
    189 │       await use(browserServer.wsEndpoint());
  

tests/fixtures.ts:195:52 lint/style/noNonNullAssertion ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Forbidden non-null assertion.
  
    193 │     cdpServer: async ({ mcpBrowser }, use, testInfo) => {
    194 │       test.skip(
  > 195 │         !['chrome', 'msedge', 'chromium'].includes(mcpBrowser!),
        │                                                    ^^^^^^^^^^^
    196 │         'CDP is not supported for non-Chromium browsers'
    197 │       );
  

tests/fixtures.ts:227:14 lint/correctness/noEmptyPattern ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Unexpected empty object pattern.
  
    226 │     _workerServers: [
  > 227 │       async ({}, use, workerInfo) => {
        │              ^^
    228 │         const port = 8907 + workerInfo.workerIndex * 4;
    229 │         const server = await TestServer.create(port);
  

tests/fixtures.ts:253:1 lint/suspicious/useAwait ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This async function lacks an await expression.
  
    251 │ );
    252 │ 
  > 253 │ async function createTransport(
        │ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  > 254 │   args: string[],
         ...
  > 298 │   };
  > 299 │ }
        │ ^
    300 │ 
    301 │ type Response = Awaited<ReturnType<Client['callTool']>>;
  
  i Remove this async modifier, or add an await expression in the function.
  
    251 │ );
    252 │ 
  > 253 │ async function createTransport(
        │ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  > 254 │   args: string[],
         ...
  > 298 │   };
  > 299 │ }
        │ ^
    300 │ 
    301 │ type Response = Awaited<ReturnType<Client['callTool']>>;
  
  i Async functions without await expressions may not need to be declared async.
  

tests/fixtures.ts:297:13 lint/style/noNonNullAssertion ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Forbidden non-null assertion.
  
    295 │   return {
    296 │     transport,
  > 297 │     stderr: transport.stderr!,
        │             ^^^^^^^^^^^^^^^^^
    298 │   };
    299 │ }
  

tests/fixtures.ts:304:46 lint/suspicious/noExplicitAny ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Unexpected any. Specify a different type.
  
    303 │ export const expect = baseExpect.extend({
  > 304 │   toHaveResponse(response: Response, object: any) {
        │                                              ^^^
    305 │     const parsed = parseResponse(response);
    306 │     const isNot = this.isNot;
  
  i any disables many type checking rules. Its use should be avoided.
  

tests/fixtures.ts:331:18 lint/performance/useTopLevelRegex ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This regex literal is not defined in the top level scope. This can lead to performance issues if this function is called frequently.
  
    329 │     .map((line) =>
    330 │       line
  > 331 │         .replace(/^pw:mcp:test /, '')
        │                  ^^^^^^^^^^^^^^^
    332 │         .replace(/user data dir.*/, 'user data dir')
    333 │         .trim()
  
  i Move the regex literal outside of this scope, and place it at the top level of this module, as a constant.
  

tests/fixtures.ts:332:18 lint/performance/useTopLevelRegex ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This regex literal is not defined in the top level scope. This can lead to performance issues if this function is called frequently.
  
    330 │       line
    331 │         .replace(/^pw:mcp:test /, '')
  > 332 │         .replace(/user data dir.*/, 'user data dir')
        │                  ^^^^^^^^^^^^^^^^^
    333 │         .trim()
    334 │     )
  
  i Move the regex literal outside of this scope, and place it at the top level of this module, as a constant.
  

tests/fixtures.ts:338:34 lint/suspicious/noExplicitAny ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Unexpected any. Specify a different type.
  
    336 │ }
    337 │ 
  > 338 │ function parseResponse(response: any) {
        │                                  ^^^
    339 │   const text = response.content[0].text;
    340 │   const sections = parseSections(text);
  
  i any disables many type checking rules. Its use should be avoided.
  

tests/fixtures.ts:349:37 lint/performance/useTopLevelRegex ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This regex literal is not defined in the top level scope. This can lead to performance issues if this function is called frequently.
  
    347 │   const modalState = sections.get('Modal state');
    348 │   const downloads = sections.get('Downloads');
  > 349 │   const codeNoFrame = code?.replace(/^```js\n/, '').replace(/\n```$/, '');
        │                                     ^^^^^^^^^^
    350 │   const isError = response.isError;
    351 │   const attachments = response.content.slice(1);
  
  i Move the regex literal outside of this scope, and place it at the top level of this module, as a constant.
  

tests/fixtures.ts:349:61 lint/performance/useTopLevelRegex ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This regex literal is not defined in the top level scope. This can lead to performance issues if this function is called frequently.
  
    347 │   const modalState = sections.get('Modal state');
    348 │   const downloads = sections.get('Downloads');
  > 349 │   const codeNoFrame = code?.replace(/^```js\n/, '').replace(/\n```$/, '');
        │                                                             ^^^^^^^^
    350 │   const isError = response.isError;
    351 │   const attachments = response.content.slice(1);
  
  i Move the regex literal outside of this scope, and place it at the top level of this module, as a constant.
  

tests/fixtures.ts:368:37 lint/performance/useTopLevelRegex ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This regex literal is not defined in the top level scope. This can lead to performance issues if this function is called frequently.
  
    366 │ function parseSections(text: string): Map<string, string> {
    367 │   const sections = new Map<string, string>();
  > 368 │   const sectionHeaders = text.split(/^### /m).slice(1); // Remove empty first element
        │                                     ^^^^^^^^
    369 │ 
    370 │   for (const section of sectionHeaders) {
  
  i Move the regex literal outside of this scope, and place it at the top level of this module, as a constant.
  

tests/headed.spec.ts:27:19 lint/nursery/noShadow ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This variable shadows another variable with the same name in the outer scope.
  
    25 │     );
    26 │     test.skip(
  > 27 │       ({ mcpMode, mcpHeadless }) => mcpMode === 'docker' && !mcpHeadless,
       │                   ^^^^^^^^^^^
    28 │       'Headed mode is not supported in docker'
    29 │     );
  
  i This is the shadowed variable, which is now inaccessible in the inner scope.
  
    17 │ import { expect, test } from './fixtures.js';
    18 │ 
  > 19 │ for (const mcpHeadless of [false, true]) {
       │            ^^^^^^^^^^^
    20 │   test.describe(`mcpHeadless: ${mcpHeadless}`, () => {
    21 │     test.use({ mcpHeadless });
  
  i Consider renaming this variable. It's easy to confuse the origin of variables if they share the same name.
  

tests/http.spec.ts:63:13 lint/nursery/noShadow ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This variable shadows another variable with the same name in the outer scope.
  
    61 │       );
    62 │       let stderr = '';
  > 63 │       const url = await new Promise<string>((resolve) =>
       │             ^^^
    64 │         cp?.stderr?.on('data', (data) => {
    65 │           stderr += data.toString();
  
  i This is the shadowed variable, which is now inaccessible in the inner scope.
  
    18 │ import fs from 'node:fs';
    19 │ import path from 'node:path';
  > 20 │ import url from 'node:url';
       │        ^^^
    21 │ import { Client } from '@modelcontextprotocol/sdk/client/index.js';
    22 │ import { StreamableHTTPClientTransport } from '@modelcontextprotocol/sdk/client/streamableHttp.js';
  
  i Consider renaming this variable. It's easy to confuse the origin of variables if they share the same name.
  

tests/http.spec.ts:142:41 lint/performance/useTopLevelRegex ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This regex literal is not defined in the top level scope. This can lead to performance issues if this function is called frequently.
  
    140 │     const lines = stderr().split('\n');
    141 │     expect(
  > 142 │       lines.filter((line) => line.match(/create http session/)).length
        │                                         ^^^^^^^^^^^^^^^^^^^^^
    143 │     ).toBe(2);
    144 │     expect(
  
  i Move the regex literal outside of this scope, and place it at the top level of this module, as a constant.
  

tests/http.spec.ts:145:41 lint/performance/useTopLevelRegex ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This regex literal is not defined in the top level scope. This can lead to performance issues if this function is called frequently.
  
    143 │     ).toBe(2);
    144 │     expect(
  > 145 │       lines.filter((line) => line.match(/delete http session/)).length
        │                                         ^^^^^^^^^^^^^^^^^^^^^
    146 │     ).toBe(2);
    147 │ 
  
  i Move the regex literal outside of this scope, and place it at the top level of this module, as a constant.
  

tests/http.spec.ts:148:46 lint/performance/useTopLevelRegex ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This regex literal is not defined in the top level scope. This can lead to performance issues if this function is called frequently.
  
    146 │     ).toBe(2);
    147 │ 
  > 148 │     expect(lines.filter((line) => line.match(/create context/)).length).toBe(2);
        │                                              ^^^^^^^^^^^^^^^^
    149 │     expect(lines.filter((line) => line.match(/close context/)).length).toBe(2);
    150 │ 
  
  i Move the regex literal outside of this scope, and place it at the top level of this module, as a constant.
  

tests/http.spec.ts:149:46 lint/performance/useTopLevelRegex ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This regex literal is not defined in the top level scope. This can lead to performance issues if this function is called frequently.
  
    148 │     expect(lines.filter((line) => line.match(/create context/)).length).toBe(2);
  > 149 │     expect(lines.filter((line) => line.match(/close context/)).length).toBe(2);
        │                                              ^^^^^^^^^^^^^^^
    150 │ 
    151 │     expect(
  
  i Move the regex literal outside of this scope, and place it at the top level of this module, as a constant.
  

tests/http.spec.ts:152:41 lint/performance/useTopLevelRegex ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This regex literal is not defined in the top level scope. This can lead to performance issues if this function is called frequently.
  
    151 │     expect(
  > 152 │       lines.filter((line) => line.match(/create browser context \(isolated\)/))
        │                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    153 │         .length
    154 │     ).toBe(2);
  
  i Move the regex literal outside of this scope, and place it at the top level of this module, as a constant.
  

tests/http.spec.ts:156:41 lint/performance/useTopLevelRegex ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This regex literal is not defined in the top level scope. This can lead to performance issues if this function is called frequently.
  
    154 │     ).toBe(2);
    155 │     expect(
  > 156 │       lines.filter((line) => line.match(/close browser context \(isolated\)/))
        │                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    157 │         .length
    158 │     ).toBe(2);
  
  i Move the regex literal outside of this scope, and place it at the top level of this module, as a constant.
  

tests/http.spec.ts:161:41 lint/performance/useTopLevelRegex ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This regex literal is not defined in the top level scope. This can lead to performance issues if this function is called frequently.
  
    160 │     expect(
  > 161 │       lines.filter((line) => line.match(/obtain browser \(isolated\)/)).length
        │                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    162 │     ).toBe(2);
    163 │     expect(
  
  i Move the regex literal outside of this scope, and place it at the top level of this module, as a constant.
  

tests/http.spec.ts:164:41 lint/performance/useTopLevelRegex ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This regex literal is not defined in the top level scope. This can lead to performance issues if this function is called frequently.
  
    162 │     ).toBe(2);
    163 │     expect(
  > 164 │       lines.filter((line) => line.match(/close browser \(isolated\)/)).length
        │                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    165 │     ).toBe(2);
    166 │   }).toPass();
  
  i Move the regex literal outside of this scope, and place it at the top level of this module, as a constant.
  

tests/http.spec.ts:206:16 lint/suspicious/useAwait ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This async function lacks an await expression.
  
    204 │   await client3.close();
    205 │ 
  > 206 │   await expect(async () => {
        │                ^^^^^^^^^^^^^
  > 207 │     const lines = stderr().split('\n');
         ...
  > 232 │     ).toBe(1);
  > 233 │   }).toPass();
        │   ^
    234 │ });
    235 │ 
  
  i Remove this async modifier, or add an await expression in the function.
  
    204 │   await client3.close();
    205 │ 
  > 206 │   await expect(async () => {
        │                ^^^^^^^^^^^^^
  > 207 │     const lines = stderr().split('\n');
         ...
  > 232 │     ).toBe(1);
  > 233 │   }).toPass();
        │   ^
    234 │ });
    235 │ 
  
  i Async functions without await expressions may not need to be declared async.
  

tests/http.spec.ts:209:41 lint/performance/useTopLevelRegex ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This regex literal is not defined in the top level scope. This can lead to performance issues if this function is called frequently.
  
    207 │     const lines = stderr().split('\n');
    208 │     expect(
  > 209 │       lines.filter((line) => line.match(/create http session/)).length
        │                                         ^^^^^^^^^^^^^^^^^^^^^
    210 │     ).toBe(3);
    211 │     expect(
  
  i Move the regex literal outside of this scope, and place it at the top level of this module, as a constant.
  

tests/http.spec.ts:212:41 lint/performance/useTopLevelRegex ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This regex literal is not defined in the top level scope. This can lead to performance issues if this function is called frequently.
  
    210 │     ).toBe(3);
    211 │     expect(
  > 212 │       lines.filter((line) => line.match(/delete http session/)).length
        │                                         ^^^^^^^^^^^^^^^^^^^^^
    213 │     ).toBe(3);
    214 │ 
  
  i Move the regex literal outside of this scope, and place it at the top level of this module, as a constant.
  

tests/http.spec.ts:215:46 lint/performance/useTopLevelRegex ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This regex literal is not defined in the top level scope. This can lead to performance issues if this function is called frequently.
  
    213 │     ).toBe(3);
    214 │ 
  > 215 │     expect(lines.filter((line) => line.match(/create context/)).length).toBe(3);
        │                                              ^^^^^^^^^^^^^^^^
    216 │     expect(lines.filter((line) => line.match(/close context/)).length).toBe(3);
    217 │ 
  
  i Move the regex literal outside of this scope, and place it at the top level of this module, as a constant.
  

tests/http.spec.ts:216:46 lint/performance/useTopLevelRegex ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This regex literal is not defined in the top level scope. This can lead to performance issues if this function is called frequently.
  
    215 │     expect(lines.filter((line) => line.match(/create context/)).length).toBe(3);
  > 216 │     expect(lines.filter((line) => line.match(/close context/)).length).toBe(3);
        │                                              ^^^^^^^^^^^^^^^
    217 │ 
    218 │     expect(
  
  i Move the regex literal outside of this scope, and place it at the top level of this module, as a constant.
  

tests/http.spec.ts:219:41 lint/performance/useTopLevelRegex ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This regex literal is not defined in the top level scope. This can lead to performance issues if this function is called frequently.
  
    218 │     expect(
  > 219 │       lines.filter((line) => line.match(/create browser context \(isolated\)/))
        │                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    220 │         .length
    221 │     ).toBe(3);
  
  i Move the regex literal outside of this scope, and place it at the top level of this module, as a constant.
  

tests/http.spec.ts:223:41 lint/performance/useTopLevelRegex ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This regex literal is not defined in the top level scope. This can lead to performance issues if this function is called frequently.
  
    221 │     ).toBe(3);
    222 │     expect(
  > 223 │       lines.filter((line) => line.match(/close browser context \(isolated\)/))
        │                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    224 │         .length
    225 │     ).toBe(3);
  
  i Move the regex literal outside of this scope, and place it at the top level of this module, as a constant.
  

tests/http.spec.ts:139:16 lint/suspicious/useAwait ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This async function lacks an await expression.
  
    137 │   await client2.close();
    138 │ 
  > 139 │   await expect(async () => {
        │                ^^^^^^^^^^^^^
  > 140 │     const lines = stderr().split('\n');
         ...
  > 165 │     ).toBe(2);
  > 166 │   }).toPass();
        │   ^
    167 │ });
    168 │ 
  
  i Remove this async modifier, or add an await expression in the function.
  
    137 │   await client2.close();
    138 │ 
  > 139 │   await expect(async () => {
        │                ^^^^^^^^^^^^^
  > 140 │     const lines = stderr().split('\n');
         ...
  > 165 │     ).toBe(2);
  > 166 │   }).toPass();
        │   ^
    167 │ });
    168 │ 
  
  i Async functions without await expressions may not need to be declared async.
  

tests/http.spec.ts:231:41 lint/performance/useTopLevelRegex ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This regex literal is not defined in the top level scope. This can lead to performance issues if this function is called frequently.
  
    229 │     ).toBe(1);
    230 │     expect(
  > 231 │       lines.filter((line) => line.match(/close browser \(isolated\)/)).length
        │                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    232 │     ).toBe(1);
    233 │   }).toPass();
  
  i Move the regex literal outside of this scope, and place it at the top level of this module, as a constant.
  

tests/http.spec.ts:262:16 lint/suspicious/useAwait ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This async function lacks an await expression.
  
    260 │   await client2.close();
    261 │ 
  > 262 │   await expect(async () => {
        │                ^^^^^^^^^^^^^
  > 263 │     const lines = stderr().split('\n');
         ...
  > 289 │     ).toBe(2);
  > 290 │   }).toPass();
        │   ^
    291 │ });
    292 │ 
  
  i Remove this async modifier, or add an await expression in the function.
  
    260 │   await client2.close();
    261 │ 
  > 262 │   await expect(async () => {
        │                ^^^^^^^^^^^^^
  > 263 │     const lines = stderr().split('\n');
         ...
  > 289 │     ).toBe(2);
  > 290 │   }).toPass();
        │   ^
    291 │ });
    292 │ 
  
  i Async functions without await expressions may not need to be declared async.
  

tests/http.spec.ts:265:41 lint/performance/useTopLevelRegex ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This regex literal is not defined in the top level scope. This can lead to performance issues if this function is called frequently.
  
    263 │     const lines = stderr().split('\n');
    264 │     expect(
  > 265 │       lines.filter((line) => line.match(/create http session/)).length
        │                                         ^^^^^^^^^^^^^^^^^^^^^
    266 │     ).toBe(2);
    267 │     expect(
  
  i Move the regex literal outside of this scope, and place it at the top level of this module, as a constant.
  

tests/http.spec.ts:268:41 lint/performance/useTopLevelRegex ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This regex literal is not defined in the top level scope. This can lead to performance issues if this function is called frequently.
  
    266 │     ).toBe(2);
    267 │     expect(
  > 268 │       lines.filter((line) => line.match(/delete http session/)).length
        │                                         ^^^^^^^^^^^^^^^^^^^^^
    269 │     ).toBe(2);
    270 │ 
  
  i Move the regex literal outside of this scope, and place it at the top level of this module, as a constant.
  

tests/http.spec.ts:271:46 lint/performance/useTopLevelRegex ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This regex literal is not defined in the top level scope. This can lead to performance issues if this function is called frequently.
  
    269 │     ).toBe(2);
    270 │ 
  > 271 │     expect(lines.filter((line) => line.match(/create context/)).length).toBe(2);
        │                                              ^^^^^^^^^^^^^^^^
    272 │     expect(lines.filter((line) => line.match(/close context/)).length).toBe(2);
    273 │ 
  
  i Move the regex literal outside of this scope, and place it at the top level of this module, as a constant.
  

tests/http.spec.ts:272:46 lint/performance/useTopLevelRegex ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This regex literal is not defined in the top level scope. This can lead to performance issues if this function is called frequently.
  
    271 │     expect(lines.filter((line) => line.match(/create context/)).length).toBe(2);
  > 272 │     expect(lines.filter((line) => line.match(/close context/)).length).toBe(2);
        │                                              ^^^^^^^^^^^^^^^
    273 │ 
    274 │     expect(
  
  i Move the regex literal outside of this scope, and place it at the top level of this module, as a constant.
  

tests/http.spec.ts:276:20 lint/performance/useTopLevelRegex ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This regex literal is not defined in the top level scope. This can lead to performance issues if this function is called frequently.
  
    274 │     expect(
    275 │       lines.filter((line) =>
  > 276 │         line.match(/create browser context \(persistent\)/)
        │                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    277 │       ).length
    278 │     ).toBe(2);
  
  i Move the regex literal outside of this scope, and place it at the top level of this module, as a constant.
  

tests/http.spec.ts:280:41 lint/performance/useTopLevelRegex ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This regex literal is not defined in the top level scope. This can lead to performance issues if this function is called frequently.
  
    278 │     ).toBe(2);
    279 │     expect(
  > 280 │       lines.filter((line) => line.match(/close browser context \(persistent\)/))
        │                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    281 │         .length
    282 │     ).toBe(2);
  
  i Move the regex literal outside of this scope, and place it at the top level of this module, as a constant.
  

tests/http.spec.ts:285:41 lint/performance/useTopLevelRegex ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This regex literal is not defined in the top level scope. This can lead to performance issues if this function is called frequently.
  
    284 │     expect(
  > 285 │       lines.filter((line) => line.match(/lock user data dir/)).length
        │                                         ^^^^^^^^^^^^^^^^^^^^
    286 │     ).toBe(2);
    287 │     expect(
  
  i Move the regex literal outside of this scope, and place it at the top level of this module, as a constant.
  

tests/http.spec.ts:288:41 lint/performance/useTopLevelRegex ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This regex literal is not defined in the top level scope. This can lead to performance issues if this function is called frequently.
  
    286 │     ).toBe(2);
    287 │     expect(
  > 288 │       lines.filter((line) => line.match(/release user data dir/)).length
        │                                         ^^^^^^^^^^^^^^^^^^^^^^^
    289 │     ).toBe(2);
    290 │   }).toPass();
  
  i Move the regex literal outside of this scope, and place it at the top level of this module, as a constant.
  

tests/http.spec.ts:66:38 lint/performance/useTopLevelRegex ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This regex literal is not defined in the top level scope. This can lead to performance issues if this function is called frequently.
  
    64 │         cp?.stderr?.on('data', (data) => {
    65 │           stderr += data.toString();
  > 66 │           const match = stderr.match(/Listening on (http:\/\/.*)/);
       │                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    67 │           if (match) {
    68 │             resolve(match[1]);
  
  i Move the regex literal outside of this scope, and place it at the top level of this module, as a constant.
  

tests/http.spec.ts:80:11 lint/nursery/noShadow ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This variable shadows another variable with the same name in the outer scope.
  
    79 │ test('http transport', async ({ serverEndpoint }) => {
  > 80 │   const { url } = await serverEndpoint();
       │           ^^^
    81 │   const transport = new StreamableHTTPClientTransport(new URL('/mcp', url));
    82 │   const client = new Client({ name: 'test', version: '1.0.0' });
  
  i This is the shadowed variable, which is now inaccessible in the inner scope.
  
    18 │ import fs from 'node:fs';
    19 │ import path from 'node:path';
  > 20 │ import url from 'node:url';
       │        ^^^
    21 │ import { Client } from '@modelcontextprotocol/sdk/client/index.js';
    22 │ import { StreamableHTTPClientTransport } from '@modelcontextprotocol/sdk/client/streamableHttp.js';
  
  i Consider renaming this variable. It's easy to confuse the origin of variables if they share the same name.
  

tests/http.spec.ts:96:11 lint/nursery/noShadow ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This variable shadows another variable with the same name in the outer scope.
  
    94 │   await fs.promises.writeFile(configFile, JSON.stringify(config, null, 2));
    95 │ 
  > 96 │   const { url } = await serverEndpoint({
       │           ^^^
    97 │     noPort: true,
    98 │     args: [`--config=${configFile}`],
  
  i This is the shadowed variable, which is now inaccessible in the inner scope.
  
    18 │ import fs from 'node:fs';
    19 │ import path from 'node:path';
  > 20 │ import url from 'node:url';
       │        ^^^
    21 │ import { Client } from '@modelcontextprotocol/sdk/client/index.js';
    22 │ import { StreamableHTTPClientTransport } from '@modelcontextprotocol/sdk/client/streamableHttp.js';
  
  i Consider renaming this variable. It's easy to confuse the origin of variables if they share the same name.
  

tests/http.spec.ts:110:11 lint/nursery/noShadow ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This variable shadows another variable with the same name in the outer scope.
  
    108 │   server,
    109 │ }) => {
  > 110 │   const { url, stderr } = await serverEndpoint({ args: ['--isolated'] });
        │           ^^^
    111 │ 
    112 │   const transport1 = new StreamableHTTPClientTransport(new URL('/mcp', url));
  
  i This is the shadowed variable, which is now inaccessible in the inner scope.
  
    18 │ import fs from 'node:fs';
    19 │ import path from 'node:path';
  > 20 │ import url from 'node:url';
       │        ^^^
    21 │ import { Client } from '@modelcontextprotocol/sdk/client/index.js';
    22 │ import { StreamableHTTPClientTransport } from '@modelcontextprotocol/sdk/client/streamableHttp.js';
  
  i Consider renaming this variable. It's easy to confuse the origin of variables if they share the same name.
  

tests/http.spec.ts:173:11 lint/nursery/noShadow ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This variable shadows another variable with the same name in the outer scope.
  
    171 │   server,
    172 │ }) => {
  > 173 │   const { url, stderr } = await serverEndpoint({ args: ['--isolated'] });
        │           ^^^
    174 │ 
    175 │   const transport1 = new StreamableHTTPClientTransport(new URL('/mcp', url));
  
  i This is the shadowed variable, which is now inaccessible in the inner scope.
  
    18 │ import fs from 'node:fs';
    19 │ import path from 'node:path';
  > 20 │ import url from 'node:url';
       │        ^^^
    21 │ import { Client } from '@modelcontextprotocol/sdk/client/index.js';
    22 │ import { StreamableHTTPClientTransport } from '@modelcontextprotocol/sdk/client/streamableHttp.js';
  
  i Consider renaming this variable. It's easy to confuse the origin of variables if they share the same name.
  

tests/http.spec.ts:240:11 lint/nursery/noShadow ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This variable shadows another variable with the same name in the outer scope.
  
    238 │   server,
    239 │ }) => {
  > 240 │   const { url, stderr } = await serverEndpoint();
        │           ^^^
    241 │ 
    242 │   const transport1 = new StreamableHTTPClientTransport(new URL('/mcp', url));
  
  i This is the shadowed variable, which is now inaccessible in the inner scope.
  
    18 │ import fs from 'node:fs';
    19 │ import path from 'node:path';
  > 20 │ import url from 'node:url';
       │        ^^^
    21 │ import { Client } from '@modelcontextprotocol/sdk/client/index.js';
    22 │ import { StreamableHTTPClientTransport } from '@modelcontextprotocol/sdk/client/streamableHttp.js';
  
  i Consider renaming this variable. It's easy to confuse the origin of variables if they share the same name.
  

tests/http.spec.ts:297:11 lint/nursery/noShadow ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This variable shadows another variable with the same name in the outer scope.
  
    295 │   server,
    296 │ }) => {
  > 297 │   const { url } = await serverEndpoint();
        │           ^^^
    298 │ 
    299 │   const transport1 = new StreamableHTTPClientTransport(new URL('/mcp', url));
  
  i This is the shadowed variable, which is now inaccessible in the inner scope.
  
    18 │ import fs from 'node:fs';
    19 │ import path from 'node:path';
  > 20 │ import url from 'node:url';
       │        ^^^
    21 │ import { Client } from '@modelcontextprotocol/sdk/client/index.js';
    22 │ import { StreamableHTTPClientTransport } from '@modelcontextprotocol/sdk/client/streamableHttp.js';
  
  i Consider renaming this variable. It's easy to confuse the origin of variables if they share the same name.
  

tests/http.spec.ts:324:11 lint/nursery/noShadow ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This variable shadows another variable with the same name in the outer scope.
  
    323 │ test('http transport (default)', async ({ serverEndpoint }) => {
  > 324 │   const { url } = await serverEndpoint();
        │           ^^^
    325 │   const transport = new StreamableHTTPClientTransport(url);
    326 │   const client = new Client({ name: 'test', version: '1.0.0' });
  
  i This is the shadowed variable, which is now inaccessible in the inner scope.
  
    18 │ import fs from 'node:fs';
    19 │ import path from 'node:path';
  > 20 │ import url from 'node:url';
       │        ^^^
    21 │ import { Client } from '@modelcontextprotocol/sdk/client/index.js';
    22 │ import { StreamableHTTPClientTransport } from '@modelcontextprotocol/sdk/client/streamableHttp.js';
  
  i Consider renaming this variable. It's easy to confuse the origin of variables if they share the same name.
  

tests/http.spec.ts:228:41 lint/performance/useTopLevelRegex ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This regex literal is not defined in the top level scope. This can lead to performance issues if this function is called frequently.
  
    227 │     expect(
  > 228 │       lines.filter((line) => line.match(/obtain browser \(isolated\)/)).length
        │                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    229 │     ).toBe(1);
    230 │     expect(
  
  i Move the regex literal outside of this scope, and place it at the top level of this module, as a constant.
  

tests/image-processor.spec.ts:119:22 lint/nursery/noAwaitInLoop ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Avoid using await inside loops.
  
    118 │     for (const format of formats) {
  > 119 │       const result = await processImage(testBuffer, 'image/png', { format });
        │                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    120 │       expect(result.contentType).toBe(`image/${format}`);
    121 │       expect(result.data).toBeInstanceOf(Buffer);
  
  i Using await inside loops might cause performance issues or unintended sequential execution, consider use Promise.all() instead.
  

tests/launch.spec.ts:21:59 lint/correctness/noUnusedFunctionParameters ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This parameter is unused.
  
    19 │ import { expect, formatOutput, test } from './fixtures.js';
    20 │ 
  > 21 │ test('test reopen browser', async ({ startClient, server, mcpMode }) => {
       │                                                           ^^^^^^^
    22 │   const { client, stderr } = await startClient();
    23 │   await client.callTool({
  
  i Unused parameters might be the result of an incomplete refactoring.
  

tests/library.spec.ts:28:10 lint/correctness/noEmptyPattern ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Unexpected empty object pattern.
  
    26 │     },
    27 │   },
  > 28 │   async ({}, testInfo) => {
       │          ^^
    29 │     const file = testInfo.outputPath('main.cjs');
    30 │     const projectRoot = process.cwd();
  

tests/navigation-context.spec.ts:262:12 lint/suspicious/noExplicitAny ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Unexpected any. Specify a different type.
  
    260 │         tabs: () => [tab],
    261 │         config: { imageResponses: 'include' },
  > 262 │       } as any;
        │            ^^^
    263 │ 
    264 │       const tab = new Tab(mockContext, page, () => {});
  
  i any disables many type checking rules. Its use should be avoided.
  

tests/navigation-context.spec.ts:17:12 lint/suspicious/noExplicitAny ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Unexpected any. Specify a different type.
  
    15 │         tabs: () => [tab],
    16 │         config: { imageResponses: 'include' },
  > 17 │       } as any;
       │            ^^^
    18 │ 
    19 │       const tab = new Tab(mockContext, page, () => {});
  
  i any disables many type checking rules. Its use should be avoided.
  

tests/navigation-context.spec.ts:19:52 lint/suspicious/noEmptyBlockStatements ━━━━━━━━━━━━━━━━━━━━━━

  × Unexpected empty block.
  
    17 │       } as any;
    18 │ 
  > 19 │       const tab = new Tab(mockContext, page, () => {});
       │                                                    ^^
    20 │ 
    21 │       // Navigate to a page that will trigger context changes
  
  i Empty blocks are usually the result of an incomplete refactoring. Remove the empty block or add a comment inside it if it is intentional.
  

tests/navigation-context.spec.ts:46:12 lint/suspicious/noExplicitAny ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Unexpected any. Specify a different type.
  
    44 │         tabs: () => [tab],
    45 │         config: { imageResponses: 'include' },
  > 46 │       } as any;
       │            ^^^
    47 │ 
    48 │       const tab = new Tab(mockContext, page, () => {});
  
  i any disables many type checking rules. Its use should be avoided.
  

tests/navigation-context.spec.ts:48:52 lint/suspicious/noEmptyBlockStatements ━━━━━━━━━━━━━━━━━━━━━━

  × Unexpected empty block.
  
    46 │       } as any;
    47 │ 
  > 48 │       const tab = new Tab(mockContext, page, () => {});
       │                                                    ^^
    49 │ 
    50 │       await page.goto('data:text/html,<html><body><h1>Test</h1></body></html>');
  
  i Empty blocks are usually the result of an incomplete refactoring. Remove the empty block or add a comment inside it if it is intentional.
  

tests/navigation-context.spec.ts:55:42 lint/suspicious/noEmptyBlockStatements ━━━━━━━━━━━━━━━━━━━━━━

  × Unexpected empty block.
  
    53 │         // Trigger a request before navigation to simulate the scenario
    54 │         await page.evaluate(() => {
  > 55 │           fetch('/api/test').catch(() => {}); // Ignore network errors in test
       │                                          ^^
    56 │         });
    57 │         // Then navigate
  
  i Empty blocks are usually the result of an incomplete refactoring. Remove the empty block or add a comment inside it if it is intentional.
  

tests/navigation-context.spec.ts:75:12 lint/suspicious/noExplicitAny ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Unexpected any. Specify a different type.
  
    73 │         tabs: () => [tab],
    74 │         config: { imageResponses: 'include' },
  > 75 │       } as any;
       │            ^^^
    76 │ 
    77 │       const tab = new Tab(mockContext, page, () => {});
  
  i any disables many type checking rules. Its use should be avoided.
  

tests/navigation-context.spec.ts:77:52 lint/suspicious/noEmptyBlockStatements ━━━━━━━━━━━━━━━━━━━━━━

  × Unexpected empty block.
  
    75 │       } as any;
    76 │ 
  > 77 │       const tab = new Tab(mockContext, page, () => {});
       │                                                    ^^
    78 │ 
    79 │       await page.goto('data:text/html,<html><body><h1>Test</h1></body></html>');
  
  i Empty blocks are usually the result of an incomplete refactoring. Remove the empty block or add a comment inside it if it is intentional.
  

tests/navigation-context.spec.ts:103:12 lint/suspicious/noExplicitAny ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Unexpected any. Specify a different type.
  
    101 │         tabs: () => [tab],
    102 │         config: { imageResponses: 'include' },
  > 103 │       } as any;
        │            ^^^
    104 │ 
    105 │       const tab = new Tab(mockContext, page, () => {});
  
  i any disables many type checking rules. Its use should be avoided.
  

tests/navigation-context.spec.ts:105:52 lint/suspicious/noEmptyBlockStatements ━━━━━━━━━━━━━━━━━━━━━

  × Unexpected empty block.
  
    103 │       } as any;
    104 │ 
  > 105 │       const tab = new Tab(mockContext, page, () => {});
        │                                                    ^^
    106 │ 
    107 │       await page.goto(
  
  i Empty blocks are usually the result of an incomplete refactoring. Remove the empty block or add a comment inside it if it is intentional.
  

tests/navigation-context.spec.ts:140:12 lint/suspicious/noExplicitAny ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Unexpected any. Specify a different type.
  
    138 │         tabs: () => [tab],
    139 │         config: { imageResponses: 'include' },
  > 140 │       } as any;
        │            ^^^
    141 │ 
    142 │       const tab = new Tab(mockContext, page, () => {});
  
  i any disables many type checking rules. Its use should be avoided.
  

tests/navigation-context.spec.ts:142:52 lint/suspicious/noEmptyBlockStatements ━━━━━━━━━━━━━━━━━━━━━

  × Unexpected empty block.
  
    140 │       } as any;
    141 │ 
  > 142 │       const tab = new Tab(mockContext, page, () => {});
        │                                                    ^^
    143 │ 
    144 │       await page.goto('data:text/html,<html><body><h1>Test</h1></body></html>');
  
  i Empty blocks are usually the result of an incomplete refactoring. Remove the empty block or add a comment inside it if it is intentional.
  

tests/navigation-context.spec.ts:174:12 lint/suspicious/noExplicitAny ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Unexpected any. Specify a different type.
  
    172 │         tabs: () => [tab],
    173 │         config: { imageResponses: 'include' },
  > 174 │       } as any;
        │            ^^^
    175 │ 
    176 │       const tab = new Tab(mockContext, page, () => {});
  
  i any disables many type checking rules. Its use should be avoided.
  

tests/navigation-context.spec.ts:176:52 lint/suspicious/noEmptyBlockStatements ━━━━━━━━━━━━━━━━━━━━━

  × Unexpected empty block.
  
    174 │       } as any;
    175 │ 
  > 176 │       const tab = new Tab(mockContext, page, () => {});
        │                                                    ^^
    177 │ 
    178 │       await page.goto(
  
  i Empty blocks are usually the result of an incomplete refactoring. Remove the empty block or add a comment inside it if it is intentional.
  

tests/navigation-context.spec.ts:215:12 lint/suspicious/noExplicitAny ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Unexpected any. Specify a different type.
  
    213 │         tabs: () => [tab],
    214 │         config: { imageResponses: 'include' },
  > 215 │       } as any;
        │            ^^^
    216 │ 
    217 │       const tab = new Tab(mockContext, page, () => {});
  
  i any disables many type checking rules. Its use should be avoided.
  

tests/navigation-context.spec.ts:217:52 lint/suspicious/noEmptyBlockStatements ━━━━━━━━━━━━━━━━━━━━━

  × Unexpected empty block.
  
    215 │       } as any;
    216 │ 
  > 217 │       const tab = new Tab(mockContext, page, () => {});
        │                                                    ^^
    218 │ 
    219 │       // Create a page that responds to Enter key with navigation
  
  i Empty blocks are usually the result of an incomplete refactoring. Remove the empty block or add a comment inside it if it is intentional.
  

tests/navigation-context.spec.ts:264:52 lint/suspicious/noEmptyBlockStatements ━━━━━━━━━━━━━━━━━━━━━

  × Unexpected empty block.
  
    262 │       } as any;
    263 │ 
  > 264 │       const tab = new Tab(mockContext, page, () => {});
        │                                                    ^^
    265 │ 
    266 │       await page.goto(
  
  i Empty blocks are usually the result of an incomplete refactoring. Remove the empty block or add a comment inside it if it is intentional.
  

tests/parallel-analysis-stability.spec.ts:46:22 lint/nursery/noAwaitInLoop ━━━━━━━━━━━━━━━━━━━━━━━━━

  × Avoid using await inside loops.
  
    45 │     for (let i = 0; i < 5; i++) {
  > 46 │       const result = await unifiedSystem.analyzePageStructure(true);
       │                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    47 │       expect(result.success).toBe(true);
    48 │       results.push(result);
  
  i Using await inside loops might cause performance issues or unintended sequential execution, consider use Promise.all() instead.
  

tests/pdf.spec.ts:111:31 lint/performance/useTopLevelRegex ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This regex literal is not defined in the top level scope. This can lead to performance issues if this function is called frequently.
  
    109 │   const pdfFiles = files.filter((f) => f.endsWith('.pdf'));
    110 │   expect(pdfFiles).toHaveLength(1);
  > 111 │   expect(pdfFiles[0]).toMatch(/^output.pdf$/);
        │                               ^^^^^^^^^^^^^^
    112 │ });
    113 │ 
  
  i Move the regex literal outside of this scope, and place it at the top level of this module, as a constant.
  

tests/pdf.spec.ts:65:35 lint/performance/useTopLevelRegex ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This regex literal is not defined in the top level scope. This can lead to performance issues if this function is called frequently.
  
    63 │   ).toHaveResponse({
    64 │     code: expect.stringContaining('await page.pdf('),
  > 65 │     result: expect.stringMatching(/Saved page as.*page-[^:]+.pdf/),
       │                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    66 │   });
    67 │ });
  
  i Move the regex literal outside of this scope, and place it at the top level of this module, as a constant.
  

tests/phase1-verification.spec.ts:19:16 lint/suspicious/useAwait ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This async function lacks an await expression.
  
    17 │     const mockResource = {
    18 │       disposed: false,
  > 19 │       dispose: async () => {
       │                ^^^^^^^^^^^^^
  > 20 │         mockResource.disposed = true;
  > 21 │       },
       │       ^
    22 │     };
    23 │ 
  
  i Remove this async modifier, or add an await expression in the function.
  
    17 │     const mockResource = {
    18 │       disposed: false,
  > 19 │       dispose: async () => {
       │                ^^^^^^^^^^^^^
  > 20 │         mockResource.disposed = true;
  > 21 │       },
       │       ^
    22 │     };
    23 │ 
  
  i Async functions without await expressions may not need to be declared async.
  

tests/response-filtering.spec.ts:36:32 lint/suspicious/noEmptyBlockStatements ━━━━━━━━━━━━━━━━━━━━━━

  × Unexpected empty block.
  
    34 │         modalStates: [],
    35 │       }),
  > 36 │       updateTitle: async () => {},
       │                                ^^
    37 │       isCurrentTab: () => true,
    38 │       lastTitle: () => 'Test Page',
  
  i Empty blocks are usually the result of an incomplete refactoring. Remove the empty block or add a comment inside it if it is intentional.
  

tests/response-filtering.spec.ts:62:22 lint/suspicious/noExplicitAny ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Unexpected any. Specify a different type.
  
    60 │     };
    61 │     const response = new Response(
  > 62 │       mockContext as any,
       │                      ^^^
    63 │       'navigate',
    64 │       { url: 'test' },
  
  i any disables many type checking rules. Its use should be avoided.
  

tests/response-filtering.spec.ts:93:22 lint/suspicious/noExplicitAny ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Unexpected any. Specify a different type.
  
    92 │     const response = new Response(
  > 93 │       mockContext as any,
       │                      ^^^
    94 │       'click',
    95 │       { element: 'button' },
  
  i any disables many type checking rules. Its use should be avoided.
  

tests/response-filtering.spec.ts:121:22 lint/suspicious/noExplicitAny ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Unexpected any. Specify a different type.
  
    120 │     const response = new Response(
  > 121 │       mockContext as any,
        │                      ^^^
    122 │       'click',
    123 │       { element: 'button' },
  
  i any disables many type checking rules. Its use should be avoided.
  

tests/response-filtering.spec.ts:151:22 lint/suspicious/noExplicitAny ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Unexpected any. Specify a different type.
  
    150 │     const response = new Response(
  > 151 │       mockContext as any,
        │                      ^^^
    152 │       'navigate',
    153 │       { url: 'test' },
  
  i any disables many type checking rules. Its use should be avoided.
  

tests/response-filtering.spec.ts:171:22 lint/suspicious/noExplicitAny ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Unexpected any. Specify a different type.
  
    169 │     // Screenshot tool should have minimal output by default
    170 │     const response = new Response(
  > 171 │       mockContext as any,
        │                      ^^^
    172 │       'browser_take_screenshot',
    173 │       {}
  
  i any disables many type checking rules. Its use should be avoided.
  

tests/response-filtering.spec.ts:198:22 lint/suspicious/noExplicitAny ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Unexpected any. Specify a different type.
  
    197 │     const response = new Response(
  > 198 │       mockContext as any,
        │                      ^^^
    199 │       'click',
    200 │       { element: 'button' },
  
  i any disables many type checking rules. Its use should be avoided.
  

tests/response-filtering.spec.ts:216:51 lint/suspicious/useAwait ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This async function lacks an await expression.
  
    214 │   });
    215 │ 
  > 216 │   test('should handle console filtering options', async () => {
        │                                                   ^^^^^^^^^^^^^
  > 217 │     const mockContext = createMockContext();
         ...
  > 241 │     expect(response._expectation?.consoleOptions?.maxMessages).toBe(3);
  > 242 │   });
        │   ^
    243 │ 
    244 │   test('should handle snapshot filtering options', async () => {
  
  i Remove this async modifier, or add an await expression in the function.
  
    214 │   });
    215 │ 
  > 216 │   test('should handle console filtering options', async () => {
        │                                                   ^^^^^^^^^^^^^
  > 217 │     const mockContext = createMockContext();
         ...
  > 241 │     expect(response._expectation?.consoleOptions?.maxMessages).toBe(3);
  > 242 │   });
        │   ^
    243 │ 
    244 │   test('should handle snapshot filtering options', async () => {
  
  i Async functions without await expressions may not need to be declared async.
  

tests/response-filtering.spec.ts:229:22 lint/suspicious/noExplicitAny ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Unexpected any. Specify a different type.
  
    228 │     const response = new Response(
  > 229 │       mockContext as any,
        │                      ^^^
    230 │       'evaluate',
    231 │       { code: 'console.log("test")' },
  
  i any disables many type checking rules. Its use should be avoided.
  

tests/response-filtering.spec.ts:244:52 lint/suspicious/useAwait ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This async function lacks an await expression.
  
    242 │   });
    243 │ 
  > 244 │   test('should handle snapshot filtering options', async () => {
        │                                                    ^^^^^^^^^^^^^
  > 245 │     const mockContext = createMockContext();
         ...
  > 266 │     expect(response._expectation?.snapshotOptions?.format).toBe('text');
  > 267 │   });
        │   ^
    268 │ });
    269 │ 
  
  i Remove this async modifier, or add an await expression in the function.
  
    242 │   });
    243 │ 
  > 244 │   test('should handle snapshot filtering options', async () => {
        │                                                    ^^^^^^^^^^^^^
  > 245 │     const mockContext = createMockContext();
         ...
  > 266 │     expect(response._expectation?.snapshotOptions?.format).toBe('text');
  > 267 │   });
        │   ^
    268 │ });
    269 │ 
  
  i Async functions without await expressions may not need to be declared async.
  

tests/response-filtering.spec.ts:256:22 lint/suspicious/noExplicitAny ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Unexpected any. Specify a different type.
  
    255 │     const response = new Response(
  > 256 │       mockContext as any,
        │                      ^^^
    257 │       'navigate',
    258 │       { url: 'test' },
  
  i any disables many type checking rules. Its use should be avoided.
  

tests/response-partial-snapshot.spec.ts:119:33 lint/performance/useTopLevelRegex ━━━━━━━━━━━━━━━━━━━

  × This regex literal is not defined in the top level scope. This can lead to performance issues if this function is called frequently.
  
    117 │     // Should fall back to full snapshot
    118 │     const content = result.content[0].text;
  > 119 │     expect(content).not.toMatch(/element \[\.non-existent-selector\]:/);
        │                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    120 │     expect(content).toContain('generic'); // Full snapshot contains page structure (div becomes generic in ARIA tree)
    121 │   });
  
  i Move the regex literal outside of this scope, and place it at the top level of this module, as a constant.
  

tests/roots.spec.ts:56:3 lint/correctness/noUnusedFunctionParameters ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This parameter is unused.
  
    54 │   startClient,
    55 │   server,
  > 56 │   mcpMode,
       │   ^^^^^^^
    57 │ }, testInfo) => {
    58 │   const rootPath = testInfo.outputPath('workspace');
  
  i Unused parameters might be the result of an incomplete refactoring.
  

tests/screenshot.spec.ts:390:3 lint/correctness/noUnusedFunctionParameters ━━━━━━━━━━━━━━━━━━━━━━━━━

  × This parameter is unused.
  
    388 │ test('browser_take_screenshot (viewport without snapshot)', async ({
    389 │   startClient,
  > 390 │   server,
        │   ^^^^^^
    391 │ }, testInfo) => {
    392 │   const { client } = await startClient({
  
  i Unused parameters might be the result of an incomplete refactoring.
  

tests/screenshot.spec.ts:122:5 lint/performance/useTopLevelRegex ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This regex literal is not defined in the top level scope. This can lead to performance issues if this function is called frequently.
  
    120 │   expect(files).toHaveLength(1);
    121 │   expect(files[0]).toMatch(
  > 122 │     /^page-\d{4}-\d{2}-\d{2}T\d{2}-\d{2}-\d{2}-\d{3}Z\.png$/
        │     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    123 │   );
    124 │ });
  
  i Move the regex literal outside of this scope, and place it at the top level of this module, as a constant.
  

tests/screenshot.spec.ts:206:11 lint/performance/useTopLevelRegex ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This regex literal is not defined in the top level scope. This can lead to performance issues if this function is called frequently.
  
    204 │       {
    205 │         text: expect.stringMatching(
  > 206 │           /page-\d{4}-\d{2}-\d{2}T\d{2}-\d{2}-\d{2}-\d{3}Z\.png/
        │           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    207 │         ),
    208 │         type: 'text',
  
  i Move the regex literal outside of this scope, and place it at the top level of this module, as a constant.
  

tests/screenshot.spec.ts:225:5 lint/performance/useTopLevelRegex ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This regex literal is not defined in the top level scope. This can lead to performance issues if this function is called frequently.
  
    223 │   expect(files).toHaveLength(1);
    224 │   expect(files[0]).toMatch(
  > 225 │     /^page-\d{4}-\d{2}-\d{2}T\d{2}-\d{2}-\d{2}-\d{3}Z\.png$/
        │     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    226 │   );
    227 │ });
  
  i Move the regex literal outside of this scope, and place it at the top level of this module, as a constant.
  

tests/screenshot.spec.ts:273:28 lint/performance/useTopLevelRegex ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This regex literal is not defined in the top level scope. This can lead to performance issues if this function is called frequently.
  
    271 │   expect(fs.existsSync(outputDir)).toBeTruthy();
    272 │   expect(files).toHaveLength(1);
  > 273 │   expect(files[0]).toMatch(/^output\.png$/);
        │                            ^^^^^^^^^^^^^^^
    274 │ });
    275 │ 
  
  i Move the regex literal outside of this scope, and place it at the top level of this module, as a constant.
  

tests/sharp-error-handling.spec.ts:40:7 lint/nursery/noAwaitInLoop ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Avoid using await inside loops.
  
    39 │       // Should throw error for invalid image data
  > 40 │       await expect(
       │       ^^^^^^^^^^^^^
  > 41 │         processImage(testCase.data, 'image/png', { quality: 80 })
  > 42 │       ).rejects.toThrow(/Image processing failed/);
       │       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    43 │     }
    44 │   });
  
  i Using await inside loops might cause performance issues or unintended sequential execution, consider use Promise.all() instead.
  

tests/sharp-error-handling.spec.ts:42:25 lint/performance/useTopLevelRegex ━━━━━━━━━━━━━━━━━━━━━━━━━

  × This regex literal is not defined in the top level scope. This can lead to performance issues if this function is called frequently.
  
    40 │       await expect(
    41 │         processImage(testCase.data, 'image/png', { quality: 80 })
  > 42 │       ).rejects.toThrow(/Image processing failed/);
       │                         ^^^^^^^^^^^^^^^^^^^^^^^^^
    43 │     }
    44 │   });
  
  i Move the regex literal outside of this scope, and place it at the top level of this module, as a constant.
  

tests/sharp-error-handling.spec.ts:100:23 lint/performance/useTopLevelRegex ━━━━━━━━━━━━━━━━━━━━━━━━

  × This regex literal is not defined in the top level scope. This can lead to performance issues if this function is called frequently.
  
     98 │     await expect(
     99 │       processImage(invalidData, 'image/png', { format: 'jpeg', quality: 80 })
  > 100 │     ).rejects.toThrow(/Image processing failed/);
        │                       ^^^^^^^^^^^^^^^^^^^^^^^^^
    101 │   });
    102 │ });
  
  i Move the regex literal outside of this scope, and place it at the top level of this module, as a constant.
  

tests/sharp-performance.spec.ts:42:11 lint/suspicious/noEvolvingTypes ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × The type of this variable may evolve implicitly to any type, including the any type.
  
    40 │     ];
    41 │ 
  > 42 │     const results = [];
       │           ^^^^^^^
    43 │     for (const options of operations) {
    44 │       const result = await processImage(testBuffer, 'image/png', options);
  
  i Add an explicit type or initialization to avoid implicit type evolution.
  

tests/sharp-performance.spec.ts:44:22 lint/nursery/noAwaitInLoop ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Avoid using await inside loops.
  
    42 │     const results = [];
    43 │     for (const options of operations) {
  > 44 │       const result = await processImage(testBuffer, 'image/png', options);
       │                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    45 │       results.push(result);
    46 │     }
  
  i Using await inside loops might cause performance issues or unintended sequential execution, consider use Promise.all() instead.
  

tests/sharp-performance.spec.ts:81:7 lint/nursery/noAwaitInLoop ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Avoid using await inside loops.
  
    79 │     // Perform multiple operations sequentially
    80 │     for (let i = 0; i < 10; i++) {
  > 81 │       await processImage(testBuffer, 'image/png', {
       │       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  > 82 │         maxWidth: 500,
  > 83 │         maxHeight: 500,
  > 84 │         quality: 85,
  > 85 │         format: 'jpeg',
  > 86 │       });
       │       ^^
    87 │ 
    88 │       // Force garbage collection if available
  
  i Using await inside loops might cause performance issues or unintended sequential execution, consider use Promise.all() instead.
  

tests/sse.spec.ts:63:13 lint/nursery/noShadow ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This variable shadows another variable with the same name in the outer scope.
  
    61 │       );
    62 │       let stderr = '';
  > 63 │       const url = await new Promise<string>((resolve) =>
       │             ^^^
    64 │         cp?.stderr?.on('data', (data) => {
    65 │           stderr += data.toString();
  
  i This is the shadowed variable, which is now inaccessible in the inner scope.
  
    18 │ import fs from 'node:fs';
    19 │ import path from 'node:path';
  > 20 │ import url from 'node:url';
       │        ^^^
    21 │ import { Client } from '@modelcontextprotocol/sdk/client/index.js';
    22 │ import { SSEClientTransport } from '@modelcontextprotocol/sdk/client/sse.js';
  
  i Consider renaming this variable. It's easy to confuse the origin of variables if they share the same name.
  

tests/sse.spec.ts:66:38 lint/performance/useTopLevelRegex ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This regex literal is not defined in the top level scope. This can lead to performance issues if this function is called frequently.
  
    64 │         cp?.stderr?.on('data', (data) => {
    65 │           stderr += data.toString();
  > 66 │           const match = stderr.match(/Listening on (http:\/\/.*)/);
       │                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    67 │           if (match) {
    68 │             resolve(match[1]);
  
  i Move the regex literal outside of this scope, and place it at the top level of this module, as a constant.
  

tests/sse.spec.ts:130:16 lint/suspicious/useAwait ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This async function lacks an await expression.
  
    128 │   await client2.close();
    129 │ 
  > 130 │   await expect(async () => {
        │                ^^^^^^^^^^^^^
  > 131 │     const lines = stderr().split('\n');
         ...
  > 156 │     ).toBe(2);
  > 157 │   }).toPass();
        │   ^
    158 │ });
    159 │ 
  
  i Remove this async modifier, or add an await expression in the function.
  
    128 │   await client2.close();
    129 │ 
  > 130 │   await expect(async () => {
        │                ^^^^^^^^^^^^^
  > 131 │     const lines = stderr().split('\n');
         ...
  > 156 │     ).toBe(2);
  > 157 │   }).toPass();
        │   ^
    158 │ });
    159 │ 
  
  i Async functions without await expressions may not need to be declared async.
  

tests/sse.spec.ts:133:41 lint/performance/useTopLevelRegex ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This regex literal is not defined in the top level scope. This can lead to performance issues if this function is called frequently.
  
    131 │     const lines = stderr().split('\n');
    132 │     expect(
  > 133 │       lines.filter((line) => line.match(/create SSE session/)).length
        │                                         ^^^^^^^^^^^^^^^^^^^^
    134 │     ).toBe(2);
    135 │     expect(
  
  i Move the regex literal outside of this scope, and place it at the top level of this module, as a constant.
  

tests/sse.spec.ts:136:41 lint/performance/useTopLevelRegex ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This regex literal is not defined in the top level scope. This can lead to performance issues if this function is called frequently.
  
    134 │     ).toBe(2);
    135 │     expect(
  > 136 │       lines.filter((line) => line.match(/delete SSE session/)).length
        │                                         ^^^^^^^^^^^^^^^^^^^^
    137 │     ).toBe(2);
    138 │ 
  
  i Move the regex literal outside of this scope, and place it at the top level of this module, as a constant.
  

tests/sse.spec.ts:139:46 lint/performance/useTopLevelRegex ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This regex literal is not defined in the top level scope. This can lead to performance issues if this function is called frequently.
  
    137 │     ).toBe(2);
    138 │ 
  > 139 │     expect(lines.filter((line) => line.match(/create context/)).length).toBe(2);
        │                                              ^^^^^^^^^^^^^^^^
    140 │     expect(lines.filter((line) => line.match(/close context/)).length).toBe(2);
    141 │ 
  
  i Move the regex literal outside of this scope, and place it at the top level of this module, as a constant.
  

tests/sse.spec.ts:140:46 lint/performance/useTopLevelRegex ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This regex literal is not defined in the top level scope. This can lead to performance issues if this function is called frequently.
  
    139 │     expect(lines.filter((line) => line.match(/create context/)).length).toBe(2);
  > 140 │     expect(lines.filter((line) => line.match(/close context/)).length).toBe(2);
        │                                              ^^^^^^^^^^^^^^^
    141 │ 
    142 │     expect(
  
  i Move the regex literal outside of this scope, and place it at the top level of this module, as a constant.
  

tests/sse.spec.ts:143:41 lint/performance/useTopLevelRegex ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This regex literal is not defined in the top level scope. This can lead to performance issues if this function is called frequently.
  
    142 │     expect(
  > 143 │       lines.filter((line) => line.match(/create browser context \(isolated\)/))
        │                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    144 │         .length
    145 │     ).toBe(2);
  
  i Move the regex literal outside of this scope, and place it at the top level of this module, as a constant.
  

tests/sse.spec.ts:147:41 lint/performance/useTopLevelRegex ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This regex literal is not defined in the top level scope. This can lead to performance issues if this function is called frequently.
  
    145 │     ).toBe(2);
    146 │     expect(
  > 147 │       lines.filter((line) => line.match(/close browser context \(isolated\)/))
        │                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    148 │         .length
    149 │     ).toBe(2);
  
  i Move the regex literal outside of this scope, and place it at the top level of this module, as a constant.
  

tests/sse.spec.ts:152:41 lint/performance/useTopLevelRegex ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This regex literal is not defined in the top level scope. This can lead to performance issues if this function is called frequently.
  
    151 │     expect(
  > 152 │       lines.filter((line) => line.match(/obtain browser \(isolated\)/)).length
        │                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    153 │     ).toBe(2);
    154 │     expect(
  
  i Move the regex literal outside of this scope, and place it at the top level of this module, as a constant.
  

tests/sse.spec.ts:155:41 lint/performance/useTopLevelRegex ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This regex literal is not defined in the top level scope. This can lead to performance issues if this function is called frequently.
  
    153 │     ).toBe(2);
    154 │     expect(
  > 155 │       lines.filter((line) => line.match(/close browser \(isolated\)/)).length
        │                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    156 │     ).toBe(2);
    157 │   }).toPass();
  
  i Move the regex literal outside of this scope, and place it at the top level of this module, as a constant.
  

tests/sse.spec.ts:194:16 lint/suspicious/useAwait ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This async function lacks an await expression.
  
    192 │   await client3.close();
    193 │ 
  > 194 │   await expect(async () => {
        │                ^^^^^^^^^^^^^
  > 195 │     const lines = stderr().split('\n');
         ...
  > 220 │     ).toBe(1);
  > 221 │   }).toPass();
        │   ^
    222 │ });
    223 │ 
  
  i Remove this async modifier, or add an await expression in the function.
  
    192 │   await client3.close();
    193 │ 
  > 194 │   await expect(async () => {
        │                ^^^^^^^^^^^^^
  > 195 │     const lines = stderr().split('\n');
         ...
  > 220 │     ).toBe(1);
  > 221 │   }).toPass();
        │   ^
    222 │ });
    223 │ 
  
  i Async functions without await expressions may not need to be declared async.
  

tests/sse.spec.ts:197:41 lint/performance/useTopLevelRegex ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This regex literal is not defined in the top level scope. This can lead to performance issues if this function is called frequently.
  
    195 │     const lines = stderr().split('\n');
    196 │     expect(
  > 197 │       lines.filter((line) => line.match(/create SSE session/)).length
        │                                         ^^^^^^^^^^^^^^^^^^^^
    198 │     ).toBe(3);
    199 │     expect(
  
  i Move the regex literal outside of this scope, and place it at the top level of this module, as a constant.
  

tests/sse.spec.ts:200:41 lint/performance/useTopLevelRegex ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This regex literal is not defined in the top level scope. This can lead to performance issues if this function is called frequently.
  
    198 │     ).toBe(3);
    199 │     expect(
  > 200 │       lines.filter((line) => line.match(/delete SSE session/)).length
        │                                         ^^^^^^^^^^^^^^^^^^^^
    201 │     ).toBe(3);
    202 │ 
  
  i Move the regex literal outside of this scope, and place it at the top level of this module, as a constant.
  

tests/sse.spec.ts:203:46 lint/performance/useTopLevelRegex ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This regex literal is not defined in the top level scope. This can lead to performance issues if this function is called frequently.
  
    201 │     ).toBe(3);
    202 │ 
  > 203 │     expect(lines.filter((line) => line.match(/create context/)).length).toBe(3);
        │                                              ^^^^^^^^^^^^^^^^
    204 │     expect(lines.filter((line) => line.match(/close context/)).length).toBe(3);
    205 │ 
  
  i Move the regex literal outside of this scope, and place it at the top level of this module, as a constant.
  

tests/sse.spec.ts:204:46 lint/performance/useTopLevelRegex ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This regex literal is not defined in the top level scope. This can lead to performance issues if this function is called frequently.
  
    203 │     expect(lines.filter((line) => line.match(/create context/)).length).toBe(3);
  > 204 │     expect(lines.filter((line) => line.match(/close context/)).length).toBe(3);
        │                                              ^^^^^^^^^^^^^^^
    205 │ 
    206 │     expect(
  
  i Move the regex literal outside of this scope, and place it at the top level of this module, as a constant.
  

tests/sse.spec.ts:283:11 lint/nursery/noShadow ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This variable shadows another variable with the same name in the outer scope.
  
    281 │   server,
    282 │ }) => {
  > 283 │   const { url } = await serverEndpoint();
        │           ^^^
    284 │ 
    285 │   const transport1 = new SSEClientTransport(new URL('/sse', url));
  
  i This is the shadowed variable, which is now inaccessible in the inner scope.
  
    18 │ import fs from 'node:fs';
    19 │ import path from 'node:path';
  > 20 │ import url from 'node:url';
       │        ^^^
    21 │ import { Client } from '@modelcontextprotocol/sdk/client/index.js';
    22 │ import { SSEClientTransport } from '@modelcontextprotocol/sdk/client/sse.js';
  
  i Consider renaming this variable. It's easy to confuse the origin of variables if they share the same name.
  

tests/sse.spec.ts:211:41 lint/performance/useTopLevelRegex ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This regex literal is not defined in the top level scope. This can lead to performance issues if this function is called frequently.
  
    209 │     ).toBe(3);
    210 │     expect(
  > 211 │       lines.filter((line) => line.match(/close browser context \(isolated\)/))
        │                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    212 │         .length
    213 │     ).toBe(3);
  
  i Move the regex literal outside of this scope, and place it at the top level of this module, as a constant.
  

tests/sse.spec.ts:216:41 lint/performance/useTopLevelRegex ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This regex literal is not defined in the top level scope. This can lead to performance issues if this function is called frequently.
  
    215 │     expect(
  > 216 │       lines.filter((line) => line.match(/obtain browser \(isolated\)/)).length
        │                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    217 │     ).toBe(1);
    218 │     expect(
  
  i Move the regex literal outside of this scope, and place it at the top level of this module, as a constant.
  

tests/sse.spec.ts:219:41 lint/performance/useTopLevelRegex ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This regex literal is not defined in the top level scope. This can lead to performance issues if this function is called frequently.
  
    217 │     ).toBe(1);
    218 │     expect(
  > 219 │       lines.filter((line) => line.match(/close browser \(isolated\)/)).length
        │                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    220 │     ).toBe(1);
    221 │   }).toPass();
  
  i Move the regex literal outside of this scope, and place it at the top level of this module, as a constant.
  

tests/sse.spec.ts:248:16 lint/suspicious/useAwait ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This async function lacks an await expression.
  
    246 │   await client2.close();
    247 │ 
  > 248 │   await expect(async () => {
        │                ^^^^^^^^^^^^^
  > 249 │     const lines = stderr().split('\n');
         ...
  > 275 │     ).toBe(2);
  > 276 │   }).toPass();
        │   ^
    277 │ });
    278 │ 
  
  i Remove this async modifier, or add an await expression in the function.
  
    246 │   await client2.close();
    247 │ 
  > 248 │   await expect(async () => {
        │                ^^^^^^^^^^^^^
  > 249 │     const lines = stderr().split('\n');
         ...
  > 275 │     ).toBe(2);
  > 276 │   }).toPass();
        │   ^
    277 │ });
    278 │ 
  
  i Async functions without await expressions may not need to be declared async.
  

tests/sse.spec.ts:251:41 lint/performance/useTopLevelRegex ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This regex literal is not defined in the top level scope. This can lead to performance issues if this function is called frequently.
  
    249 │     const lines = stderr().split('\n');
    250 │     expect(
  > 251 │       lines.filter((line) => line.match(/create SSE session/)).length
        │                                         ^^^^^^^^^^^^^^^^^^^^
    252 │     ).toBe(2);
    253 │     expect(
  
  i Move the regex literal outside of this scope, and place it at the top level of this module, as a constant.
  

tests/sse.spec.ts:254:41 lint/performance/useTopLevelRegex ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This regex literal is not defined in the top level scope. This can lead to performance issues if this function is called frequently.
  
    252 │     ).toBe(2);
    253 │     expect(
  > 254 │       lines.filter((line) => line.match(/delete SSE session/)).length
        │                                         ^^^^^^^^^^^^^^^^^^^^
    255 │     ).toBe(2);
    256 │ 
  
  i Move the regex literal outside of this scope, and place it at the top level of this module, as a constant.
  

tests/sse.spec.ts:257:46 lint/performance/useTopLevelRegex ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This regex literal is not defined in the top level scope. This can lead to performance issues if this function is called frequently.
  
    255 │     ).toBe(2);
    256 │ 
  > 257 │     expect(lines.filter((line) => line.match(/create context/)).length).toBe(2);
        │                                              ^^^^^^^^^^^^^^^^
    258 │     expect(lines.filter((line) => line.match(/close context/)).length).toBe(2);
    259 │ 
  
  i Move the regex literal outside of this scope, and place it at the top level of this module, as a constant.
  

tests/sse.spec.ts:258:46 lint/performance/useTopLevelRegex ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This regex literal is not defined in the top level scope. This can lead to performance issues if this function is called frequently.
  
    257 │     expect(lines.filter((line) => line.match(/create context/)).length).toBe(2);
  > 258 │     expect(lines.filter((line) => line.match(/close context/)).length).toBe(2);
        │                                              ^^^^^^^^^^^^^^^
    259 │ 
    260 │     expect(
  
  i Move the regex literal outside of this scope, and place it at the top level of this module, as a constant.
  

tests/sse.spec.ts:262:20 lint/performance/useTopLevelRegex ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This regex literal is not defined in the top level scope. This can lead to performance issues if this function is called frequently.
  
    260 │     expect(
    261 │       lines.filter((line) =>
  > 262 │         line.match(/create browser context \(persistent\)/)
        │                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    263 │       ).length
    264 │     ).toBe(2);
  
  i Move the regex literal outside of this scope, and place it at the top level of this module, as a constant.
  

tests/sse.spec.ts:266:41 lint/performance/useTopLevelRegex ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This regex literal is not defined in the top level scope. This can lead to performance issues if this function is called frequently.
  
    264 │     ).toBe(2);
    265 │     expect(
  > 266 │       lines.filter((line) => line.match(/close browser context \(persistent\)/))
        │                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    267 │         .length
    268 │     ).toBe(2);
  
  i Move the regex literal outside of this scope, and place it at the top level of this module, as a constant.
  

tests/sse.spec.ts:271:41 lint/performance/useTopLevelRegex ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This regex literal is not defined in the top level scope. This can lead to performance issues if this function is called frequently.
  
    270 │     expect(
  > 271 │       lines.filter((line) => line.match(/lock user data dir/)).length
        │                                         ^^^^^^^^^^^^^^^^^^^^
    272 │     ).toBe(2);
    273 │     expect(
  
  i Move the regex literal outside of this scope, and place it at the top level of this module, as a constant.
  

tests/sse.spec.ts:274:41 lint/performance/useTopLevelRegex ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This regex literal is not defined in the top level scope. This can lead to performance issues if this function is called frequently.
  
    272 │     ).toBe(2);
    273 │     expect(
  > 274 │       lines.filter((line) => line.match(/release user data dir/)).length
        │                                         ^^^^^^^^^^^^^^^^^^^^^^^
    275 │     ).toBe(2);
    276 │   }).toPass();
  
  i Move the regex literal outside of this scope, and place it at the top level of this module, as a constant.
  

tests/sse.spec.ts:80:11 lint/nursery/noShadow ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This variable shadows another variable with the same name in the outer scope.
  
    79 │ test('sse transport', async ({ serverEndpoint }) => {
  > 80 │   const { url } = await serverEndpoint();
       │           ^^^
    81 │   const transport = new SSEClientTransport(new URL('/sse', url));
    82 │   const client = new Client({ name: 'test', version: '1.0.0' });
  
  i This is the shadowed variable, which is now inaccessible in the inner scope.
  
    18 │ import fs from 'node:fs';
    19 │ import path from 'node:path';
  > 20 │ import url from 'node:url';
       │        ^^^
    21 │ import { Client } from '@modelcontextprotocol/sdk/client/index.js';
    22 │ import { SSEClientTransport } from '@modelcontextprotocol/sdk/client/sse.js';
  
  i Consider renaming this variable. It's easy to confuse the origin of variables if they share the same name.
  

tests/sse.spec.ts:96:11 lint/nursery/noShadow ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This variable shadows another variable with the same name in the outer scope.
  
    94 │   await fs.promises.writeFile(configFile, JSON.stringify(config, null, 2));
    95 │ 
  > 96 │   const { url } = await serverEndpoint({
       │           ^^^
    97 │     noPort: true,
    98 │     args: [`--config=${configFile}`],
  
  i This is the shadowed variable, which is now inaccessible in the inner scope.
  
    18 │ import fs from 'node:fs';
    19 │ import path from 'node:path';
  > 20 │ import url from 'node:url';
       │        ^^^
    21 │ import { Client } from '@modelcontextprotocol/sdk/client/index.js';
    22 │ import { SSEClientTransport } from '@modelcontextprotocol/sdk/client/sse.js';
  
  i Consider renaming this variable. It's easy to confuse the origin of variables if they share the same name.
  

tests/sse.spec.ts:110:11 lint/nursery/noShadow ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This variable shadows another variable with the same name in the outer scope.
  
    108 │   server,
    109 │ }) => {
  > 110 │   const { url, stderr } = await serverEndpoint({ args: ['--isolated'] });
        │           ^^^
    111 │ 
    112 │   const transport1 = new SSEClientTransport(new URL('/sse', url));
  
  i This is the shadowed variable, which is now inaccessible in the inner scope.
  
    18 │ import fs from 'node:fs';
    19 │ import path from 'node:path';
  > 20 │ import url from 'node:url';
       │        ^^^
    21 │ import { Client } from '@modelcontextprotocol/sdk/client/index.js';
    22 │ import { SSEClientTransport } from '@modelcontextprotocol/sdk/client/sse.js';
  
  i Consider renaming this variable. It's easy to confuse the origin of variables if they share the same name.
  

tests/sse.spec.ts:164:11 lint/nursery/noShadow ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This variable shadows another variable with the same name in the outer scope.
  
    162 │   server,
    163 │ }) => {
  > 164 │   const { url, stderr } = await serverEndpoint({ args: ['--isolated'] });
        │           ^^^
    165 │ 
    166 │   const transport1 = new SSEClientTransport(new URL('/sse', url));
  
  i This is the shadowed variable, which is now inaccessible in the inner scope.
  
    18 │ import fs from 'node:fs';
    19 │ import path from 'node:path';
  > 20 │ import url from 'node:url';
       │        ^^^
    21 │ import { Client } from '@modelcontextprotocol/sdk/client/index.js';
    22 │ import { SSEClientTransport } from '@modelcontextprotocol/sdk/client/sse.js';
  
  i Consider renaming this variable. It's easy to confuse the origin of variables if they share the same name.
  

tests/sse.spec.ts:228:11 lint/nursery/noShadow ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This variable shadows another variable with the same name in the outer scope.
  
    226 │   server,
    227 │ }) => {
  > 228 │   const { url, stderr } = await serverEndpoint();
        │           ^^^
    229 │ 
    230 │   const transport1 = new SSEClientTransport(new URL('/sse', url));
  
  i This is the shadowed variable, which is now inaccessible in the inner scope.
  
    18 │ import fs from 'node:fs';
    19 │ import path from 'node:path';
  > 20 │ import url from 'node:url';
       │        ^^^
    21 │ import { Client } from '@modelcontextprotocol/sdk/client/index.js';
    22 │ import { SSEClientTransport } from '@modelcontextprotocol/sdk/client/sse.js';
  
  i Consider renaming this variable. It's easy to confuse the origin of variables if they share the same name.
  

tests/sse.spec.ts:207:41 lint/performance/useTopLevelRegex ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This regex literal is not defined in the top level scope. This can lead to performance issues if this function is called frequently.
  
    206 │     expect(
  > 207 │       lines.filter((line) => line.match(/create browser context \(isolated\)/))
        │                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    208 │         .length
    209 │     ).toBe(3);
  
  i Move the regex literal outside of this scope, and place it at the top level of this module, as a constant.
  

tests/test-helpers.ts:156:14 lint/suspicious/useAwait ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This async function lacks an await expression.
  
    154 │ ): any {
    155 │   return {
  > 156 │     dispose: async () => {
        │              ^^^^^^^^^^^^^
  > 157 │       if (options.disposeError) {
  > 158 │         throw options.disposeError;
  > 159 │       }
  > 160 │     },
        │     ^
    161 │     textContent: async () => options.textContent || 'mock content',
    162 │     getAttribute: async (name: string) => options.attributes?.[name] || null,
  
  i Remove this async modifier, or add an await expression in the function.
  
    154 │ ): any {
    155 │   return {
  > 156 │     dispose: async () => {
        │              ^^^^^^^^^^^^^
  > 157 │       if (options.disposeError) {
  > 158 │         throw options.disposeError;
  > 159 │       }
  > 160 │     },
        │     ^
    161 │     textContent: async () => options.textContent || 'mock content',
    162 │     getAttribute: async (name: string) => options.attributes?.[name] || null,
  
  i Async functions without await expressions may not need to be declared async.
  

tests/test-helpers.ts:163:27 lint/complexity/noBannedTypes ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Don't use 'Function' as a type.
  
    161 │     textContent: async () => options.textContent || 'mock content',
    162 │     getAttribute: async (name: string) => options.attributes?.[name] || null,
  > 163 │     evaluate: async (_fn: Function) => options.selector || 'mock-selector',
        │                           ^^^^^^^^
    164 │   };
    165 │ }
  
  i Prefer explicitly define the function shape. This type accepts any function-like value, which can be a common source of bugs.
  

tests/test-helpers.ts:23:35 lint/suspicious/noExplicitAny ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Unexpected any. Specify a different type.
  
    21 │     for (const method of methods) {
    22 │       this.originalMethods.set(method, console[method]);
  > 23 │       console[method] = (...args: any[]) => {
       │                                   ^^^
    24 │         this.capturedMessages.push({ level: method, args });
    25 │         // Optionally call original method for debugging
  
  i any disables many type checking rules. Its use should be avoided.
  

tests/test-helpers.ts:44:54 lint/suspicious/noExplicitAny ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Unexpected any. Specify a different type.
  
    42 │    * Get all captured messages
    43 │    */
  > 44 │   getMessages(): Array<{ level: ConsoleMethod; args: any[] }> {
       │                                                      ^^^
    45 │     return [...this.capturedMessages];
    46 │   }
  
  i any disables many type checking rules. Its use should be avoided.
  

tests/test-helpers.ts:51:46 lint/suspicious/noExplicitAny ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Unexpected any. Specify a different type.
  
    49 │    * Get messages for a specific level
    50 │    */
  > 51 │   getMessagesForLevel(level: ConsoleMethod): any[][] {
       │                                              ^^^
    52 │     return this.capturedMessages
    53 │       .filter((msg) => msg.level === level)
  
  i any disables many type checking rules. Its use should be avoided.
  

tests/test-helpers.ts:60:19 lint/suspicious/noExplicitAny ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Unexpected any. Specify a different type.
  
    58 │    * Get warn messages (backward compatibility)
    59 │    */
  > 60 │   getWarnCalls(): any[][] {
       │                   ^^^
    61 │     return this.getMessagesForLevel('warn');
    62 │   }
  
  i any disables many type checking rules. Its use should be avoided.
  

tests/test-helpers.ts:114:28 lint/suspicious/noExplicitAny ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Unexpected any. Specify a different type.
  
    113 │     // Reset SmartConfigManager
  > 114 │     (SmartConfigManager as any).instance = null;
        │                            ^^^
    115 │ 
    116 │     // Start console capture if requested
  
  i any disables many type checking rules. Its use should be avoided.
  

tests/test-helpers.ts:133:28 lint/suspicious/noExplicitAny ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Unexpected any. Specify a different type.
  
    131 │     // Reset instances
    132 │     DiagnosticThresholds.reset();
  > 133 │     (SmartConfigManager as any).instance = null;
        │                            ^^^
    134 │   }
    135 │ 
  
  i any disables many type checking rules. Its use should be avoided.
  

tests/test-helpers.ts:154:4 lint/suspicious/noExplicitAny ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Unexpected any. Specify a different type.
  
    152 │     selector?: string;
    153 │   } = {}
  > 154 │ ): any {
        │    ^^^
    155 │   return {
    156 │     dispose: async () => {
  
  i any disables many type checking rules. Its use should be avoided.
  

tests/test-helpers.ts:170:42 lint/suspicious/noExplicitAny ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Unexpected any. Specify a different type.
  
    168 │  * Create a mock page with elements
    169 │  */
  > 170 │ export function createMockPage(elements: any[] = []): any {
        │                                          ^^^
    171 │   return {
    172 │     $$: async (_selector: string) => elements,
  
  i any disables many type checking rules. Its use should be avoided.
  

tests/test-helpers.ts:170:55 lint/suspicious/noExplicitAny ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Unexpected any. Specify a different type.
  
    168 │  * Create a mock page with elements
    169 │  */
  > 170 │ export function createMockPage(elements: any[] = []): any {
        │                                                       ^^^
    171 │   return {
    172 │     $$: async (_selector: string) => elements,
  
  i any disables many type checking rules. Its use should be avoided.
  

tests/test-helpers.ts:182:4 lint/suspicious/noExplicitAny ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Unexpected any. Specify a different type.
  
    180 │   count: number,
    181 │   errorIndices: number[] = []
  > 182 │ ): any[] {
        │    ^^^
    183 │   return Array.from({ length: count }, (_, i) => {
    184 │     const shouldError = errorIndices.includes(i);
  
  i any disables many type checking rules. Its use should be avoided.
  

tests/test-helpers.ts:254:10 lint/suspicious/noExplicitAny ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Unexpected any. Specify a different type.
  
    252 │  */
    253 │ export function expectDiagnosticError(
  > 254 │   error: any,
        │          ^^^
    255 │   expectedComponent: string,
    256 │   expectedOperation: string
  
  i any disables many type checking rules. Its use should be avoided.
  

tests/test-helpers.ts:14:47 lint/complexity/noBannedTypes ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Don't use 'Function' as a type.
  
    12 │  */
    13 │ export class ConsoleCapture {
  > 14 │   private originalMethods: Map<ConsoleMethod, Function> = new Map();
       │                                               ^^^^^^^^
    15 │   private capturedMessages: Array<{ level: ConsoleMethod; args: any[] }> = [];
    16 │ 
  
  i Prefer explicitly define the function shape. This type accepts any function-like value, which can be a common source of bugs.
  

tests/test-helpers.ts:22:40 lint/suspicious/noConsole ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Don't use console.
  
    20 │   start(methods: ConsoleMethod[] = ['warn', 'error', 'info']): void {
    21 │     for (const method of methods) {
  > 22 │       this.originalMethods.set(method, console[method]);
       │                                        ^^^^^^^^^^^^^^^
    23 │       console[method] = (...args: any[]) => {
    24 │         this.capturedMessages.push({ level: method, args });
  
  i The use of console is often reserved for debugging.
  

tests/test-helpers.ts:15:65 lint/suspicious/noExplicitAny ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Unexpected any. Specify a different type.
  
    13 │ export class ConsoleCapture {
    14 │   private originalMethods: Map<ConsoleMethod, Function> = new Map();
  > 15 │   private capturedMessages: Array<{ level: ConsoleMethod; args: any[] }> = [];
       │                                                                 ^^^
    16 │ 
    17 │   /**
  
  i any disables many type checking rules. Its use should be avoided.
  

tests/testserver/index.ts:165:21 lint/suspicious/noExplicitAny ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Unexpected any. Specify a different type.
  
    163 │   _onRequest(request: http.IncomingMessage, response: http.ServerResponse) {
    164 │     request.on('error', (error) => {
  > 165 │       if ((error as any).code === 'ECONNRESET') {
        │                     ^^^
    166 │         response.end();
    167 │       } else {
  
  i any disables many type checking rules. Its use should be avoided.
  

tests/testserver/index.ts:171:17 lint/suspicious/noExplicitAny ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Unexpected any. Specify a different type.
  
    169 │       }
    170 │     });
  > 171 │     (request as any).postBody = new Promise((resolve) => {
        │                 ^^^
    172 │       const chunks: Buffer[] = [];
    173 │       request.on('data', (chunk) => {
  
  i any disables many type checking rules. Its use should be avoided.
  

tests/testserver/index.ts:88:19 lint/nursery/noShadow ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This variable shadows another variable with the same name in the outer scope.
  
    86 │   }
    87 │ 
  > 88 │   setExtraHeaders(path: string, object: Record<string, string>) {
       │                   ^^^^
    89 │     this._extraHeaders.set(path, object);
    90 │   }
  
  i This is the shadowed variable, which is now inaccessible in the inner scope.
  
    19 │ import http from 'node:http';
    20 │ import https from 'node:https';
  > 21 │ import path from 'node:path';
       │        ^^^^
    22 │ import url from 'node:url';
    23 │ import debug from 'debug';
  
  i Consider renaming this variable. It's easy to confuse the origin of variables if they share the same name.
  

tests/testserver/index.ts:84:10 lint/nursery/noShadow ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This variable shadows another variable with the same name in the outer scope.
  
    82 │   }
    83 │ 
  > 84 │   setCSP(path: string, csp: string) {
       │          ^^^^
    85 │     this._csp.set(path, csp);
    86 │   }
  
  i This is the shadowed variable, which is now inaccessible in the inner scope.
  
    19 │ import http from 'node:http';
    20 │ import https from 'node:https';
  > 21 │ import path from 'node:path';
       │        ^^^^
    22 │ import url from 'node:url';
    23 │ import debug from 'debug';
  
  i Consider renaming this variable. It's easy to confuse the origin of variables if they share the same name.
  

tests/testserver/index.ts:33:25 lint/suspicious/noExplicitAny ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Unexpected any. Specify a different type.
  
    31 │ export class TestServer {
    32 │   private _server: http.Server;
  > 33 │   readonly debugServer: any;
       │                         ^^^
    34 │   private _routes = new Map<
    35 │     string,
  
  i any disables many type checking rules. Its use should be avoided.
  

tests/testserver/index.ts:36:71 lint/suspicious/noExplicitAny ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Unexpected any. Specify a different type.
  
    34 │   private _routes = new Map<
    35 │     string,
  > 36 │     (request: http.IncomingMessage, response: http.ServerResponse) => any
       │                                                                       ^^^
    37 │   >();
    38 │   private _csp = new Map<string, string>();
  
  i any disables many type checking rules. Its use should be avoided.
  

tests/testserver/index.ts:122:18 lint/nursery/noShadow ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This variable shadows another variable with the same name in the outer scope.
  
    120 │   }
    121 │ 
  > 122 │   waitForRequest(path: string): Promise<http.IncomingMessage> {
        │                  ^^^^
    123 │     let promise = this._requestSubscribers.get(path);
    124 │     if (promise) {
  
  i This is the shadowed variable, which is now inaccessible in the inner scope.
  
    19 │ import http from 'node:http';
    20 │ import https from 'node:https';
  > 21 │ import path from 'node:path';
       │        ^^^^
    22 │ import url from 'node:url';
    23 │ import debug from 'debug';
  
  i Consider renaming this variable. It's easy to confuse the origin of variables if they share the same name.
  

tests/testserver/index.ts:40:57 lint/suspicious/noExplicitAny ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Unexpected any. Specify a different type.
  
    38 │   private _csp = new Map<string, string>();
    39 │   private _extraHeaders = new Map<string, object>();
  > 40 │   private _requestSubscribers = new Map<string, Promise<any>>();
       │                                                         ^^^
    41 │   readonly PORT: number;
    42 │   readonly PREFIX: string;
  
  i any disables many type checking rules. Its use should be avoided.
  

tests/testserver/index.ts:102:10 lint/suspicious/noExplicitAny ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Unexpected any. Specify a different type.
  
    100 │       request: http.IncomingMessage,
    101 │       response: http.ServerResponse
  > 102 │     ) => any
        │          ^^^
    103 │   ) {
    104 │     this._routes.set(path, handler);
  
  i any disables many type checking rules. Its use should be avoided.
  

tests/testserver/index.ts:116:46 lint/style/noNonNullAssertion ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Forbidden non-null assertion.
  
    114 │   redirect(from: string, to: string) {
    115 │     this.route(from, (req, res) => {
  > 116 │       const headers = this._extraHeaders.get(req.url!) || {};
        │                                              ^^^^^^^^
    117 │       res.writeHead(302, { ...headers, location: to });
    118 │       res.end();
  

tests/testserver/index.ts:127:9 lint/suspicious/noImplicitAnyLet ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This variable implicitly has the any type.
  
    125 │       return promise;
    126 │     }
  > 127 │     let fulfill, reject;
        │         ^^^^^^^
    128 │     promise = new Promise((f, r) => {
    129 │       fulfill = f;
  
  i Variable declarations without type annotation and initialization implicitly have the any type. Declare a type or initialize the variable with some value.
  

tests/testserver/index.ts:178:11 lint/nursery/noShadow ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This variable shadows another variable with the same name in the outer scope.
  
    176 │       request.on('end', () => resolve(Buffer.concat(chunks)));
    177 │     });
  > 178 │     const path = request.url || '/';
        │           ^^^^
    179 │     this.debugServer(`request ${request.method} ${path}`);
    180 │     // Notify request subscriber.
  
  i This is the shadowed variable, which is now inaccessible in the inner scope.
  
    19 │ import http from 'node:http';
    20 │ import https from 'node:https';
  > 21 │ import path from 'node:path';
       │        ^^^^
    22 │ import url from 'node:url';
    23 │ import debug from 'debug';
  
  i Consider renaming this variable. It's easy to confuse the origin of variables if they share the same name.
  

tests/testserver/index.ts:127:9 lint/suspicious/noEvolvingTypes ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × The type of this variable may evolve implicitly to any type, including the any type.
  
    125 │       return promise;
    126 │     }
  > 127 │     let fulfill, reject;
        │         ^^^^^^^
    128 │     promise = new Promise((f, r) => {
    129 │       fulfill = f;
  
  i Add an explicit type or initialization to avoid implicit type evolution.
  

tests/testserver/index.ts:98:5 lint/nursery/noShadow ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This variable shadows another variable with the same name in the outer scope.
  
     97 │   route(
   > 98 │     path: string,
        │     ^^^^
     99 │     handler: (
    100 │       request: http.IncomingMessage,
  
  i This is the shadowed variable, which is now inaccessible in the inner scope.
  
    19 │ import http from 'node:http';
    20 │ import https from 'node:https';
  > 21 │ import path from 'node:path';
       │        ^^^^
    22 │ import url from 'node:url';
    23 │ import debug from 'debug';
  
  i Consider renaming this variable. It's easy to confuse the origin of variables if they share the same name.
  

tests/testserver/index.ts:107:14 lint/nursery/noShadow ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This variable shadows another variable with the same name in the outer scope.
  
    105 │   }
    106 │ 
  > 107 │   setContent(path: string, content: string, mimeType: string) {
        │              ^^^^
    108 │     this.route(path, (_req, res) => {
    109 │       res.writeHead(200, { 'Content-Type': mimeType });
  
  i This is the shadowed variable, which is now inaccessible in the inner scope.
  
    19 │ import http from 'node:http';
    20 │ import https from 'node:https';
  > 21 │ import path from 'node:path';
       │        ^^^^
    22 │ import url from 'node:url';
    23 │ import debug from 'debug';
  
  i Consider renaming this variable. It's easy to confuse the origin of variables if they share the same name.
  

tests/trace.spec.ts:24:3 lint/correctness/noUnusedFunctionParameters ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This parameter is unused.
  
    22 │   startClient,
    23 │   server,
  > 24 │   mcpMode,
       │   ^^^^^^^
    25 │ }, testInfo) => {
    26 │   const outputDir = testInfo.outputPath('output');
  
  i Unused parameters might be the result of an incomplete refactoring.
  

tests/unified-system-initialization.spec.ts:138:55 lint/suspicious/noExplicitAny ━━━━━━━━━━━━━━━━━━━

  × Unexpected any. Specify a different type.
  
    137 │       // Simulate partial initialization failure
  > 138 │       const cleanupPartialInitialization = (system as any)
        │                                                       ^^^
    139 │         .cleanupPartialInitialization;
    140 │ 
  
  i any disables many type checking rules. Its use should be avoided.
  

tests/unified-system-initialization.spec.ts:29:68 lint/suspicious/useAwait ━━━━━━━━━━━━━━━━━━━━━━━━━

  × This async function lacks an await expression.
  
    27 │     });
    28 │ 
  > 29 │     test('should fail when initializeComponents is not available', async ({
       │                                                                    ^^^^^^^^
  > 30 │       page,
        ...
  > 41 │       UnifiedDiagnosticSystem.disposeInstance(page);
  > 42 │     });
       │     ^
    43 │ 
    44 │     test('should handle partial initialization failure with cleanup', async ({
  
  i Remove this async modifier, or add an await expression in the function.
  
    27 │     });
    28 │ 
  > 29 │     test('should fail when initializeComponents is not available', async ({
       │                                                                    ^^^^^^^^
  > 30 │       page,
        ...
  > 41 │       UnifiedDiagnosticSystem.disposeInstance(page);
  > 42 │     });
       │     ^
    43 │ 
    44 │     test('should handle partial initialization failure with cleanup', async ({
  
  i Async functions without await expressions may not need to be declared async.
  

tests/unified-system-initialization.spec.ts:14:70 lint/suspicious/useAwait ━━━━━━━━━━━━━━━━━━━━━━━━━

  × This async function lacks an await expression.
  
    13 │   test.describe('initializeComponents method', () => {
  > 14 │     test('should initialize components in correct dependency order', async ({
       │                                                                      ^^^^^^^^
  > 15 │       page,
        ...
  > 26 │       UnifiedDiagnosticSystem.disposeInstance(page);
  > 27 │     });
       │     ^
    28 │ 
    29 │     test('should fail when initializeComponents is not available', async ({
  
  i Remove this async modifier, or add an await expression in the function.
  
    13 │   test.describe('initializeComponents method', () => {
  > 14 │     test('should initialize components in correct dependency order', async ({
       │                                                                      ^^^^^^^^
  > 15 │       page,
        ...
  > 26 │       UnifiedDiagnosticSystem.disposeInstance(page);
  > 27 │     });
       │     ^
    28 │ 
    29 │     test('should fail when initializeComponents is not available', async ({
  
  i Async functions without await expressions may not need to be declared async.
  

tests/unified-system-initialization.spec.ts:144:32 lint/suspicious/noEmptyBlockStatements ━━━━━━━━━━

  × Unexpected empty block.
  
    142 │         // Mock component with dispose method
    143 │         const mockComponent = {
  > 144 │           dispose: async () => {},
        │                                ^^
    145 │         };
    146 │         await cleanupPartialInitialization([mockComponent]);
  
  i Empty blocks are usually the result of an incomplete refactoring. Remove the empty block or add a comment inside it if it is intentional.
  

tests/unified-system-initialization.spec.ts:167:51 lint/suspicious/noExplicitAny ━━━━━━━━━━━━━━━━━━━

  × Unexpected any. Specify a different type.
  
    165 │         try {
    166 │           // Force an initialization error
  > 167 │           const originalPageAnalyzer = (system as any).pageAnalyzer;
        │                                                   ^^^
    168 │           (system as any).pageAnalyzer = null; // Simulate component failure
    169 │ 
  
  i any disables many type checking rules. Its use should be avoided.
  

tests/unified-system-initialization.spec.ts:168:22 lint/suspicious/noExplicitAny ━━━━━━━━━━━━━━━━━━━

  × Unexpected any. Specify a different type.
  
    166 │           // Force an initialization error
    167 │           const originalPageAnalyzer = (system as any).pageAnalyzer;
  > 168 │           (system as any).pageAnalyzer = null; // Simulate component failure
        │                      ^^^
    169 │ 
    170 │           await initializeComponents();
  
  i any disables many type checking rules. Its use should be avoided.
  

tests/unified-system-initialization.spec.ts:93:53 lint/suspicious/useAwait ━━━━━━━━━━━━━━━━━━━━━━━━━

  × This async function lacks an await expression.
  
     92 │   test.describe('Enhanced constructor integration', () => {
   > 93 │     test('should use async initialization pattern', async ({ page }) => {
        │                                                     ^^^^^^^^^^^^^^^^^^^^^
   > 94 │       // Current constructor is synchronous - this test should guide the change
         ...
  > 109 │       UnifiedDiagnosticSystem.disposeInstance(page);
  > 110 │     });
        │     ^
    111 │ 
    112 │     test('should handle initialization state management', async ({ page }) => {
  
  i Remove this async modifier, or add an await expression in the function.
  
     92 │   test.describe('Enhanced constructor integration', () => {
   > 93 │     test('should use async initialization pattern', async ({ page }) => {
        │                                                     ^^^^^^^^^^^^^^^^^^^^^
   > 94 │       // Current constructor is synchronous - this test should guide the change
         ...
  > 109 │       UnifiedDiagnosticSystem.disposeInstance(page);
  > 110 │     });
        │     ^
    111 │ 
    112 │     test('should handle initialization state management', async ({ page }) => {
  
  i Async functions without await expressions may not need to be declared async.
  

tests/unified-system-initialization.spec.ts:112:59 lint/suspicious/useAwait ━━━━━━━━━━━━━━━━━━━━━━━━

  × This async function lacks an await expression.
  
    110 │     });
    111 │ 
  > 112 │     test('should handle initialization state management', async ({ page }) => {
        │                                                           ^^^^^^^^^^^^^^^^^^^^^
  > 113 │       system = UnifiedDiagnosticSystem.getInstance(page);
         ...
  > 127 │       UnifiedDiagnosticSystem.disposeInstance(page);
  > 128 │     });
        │     ^
    129 │   });
    130 │ 
  
  i Remove this async modifier, or add an await expression in the function.
  
    110 │     });
    111 │ 
  > 112 │     test('should handle initialization state management', async ({ page }) => {
        │                                                           ^^^^^^^^^^^^^^^^^^^^^
  > 113 │       system = UnifiedDiagnosticSystem.getInstance(page);
         ...
  > 127 │       UnifiedDiagnosticSystem.disposeInstance(page);
  > 128 │     });
        │     ^
    129 │   });
    130 │ 
  
  i Async functions without await expressions may not need to be declared async.
  

tests/unified-system-initialization.spec.ts:173:22 lint/suspicious/noExplicitAny ━━━━━━━━━━━━━━━━━━━

  × Unexpected any. Specify a different type.
  
    172 │           // Restore for cleanup
  > 173 │           (system as any).pageAnalyzer = originalPageAnalyzer;
        │                      ^^^
    174 │         } catch (error) {
    175 │           expect(error).toBeInstanceOf(DiagnosticError);
  
  i any disables many type checking rules. Its use should be avoided.
  

tests/unified-system-initialization.spec.ts:220:45 lint/suspicious/noExplicitAny ━━━━━━━━━━━━━━━━━━━

  × Unexpected any. Specify a different type.
  
    218 │     }) => {
    219 │       // Similar to Context.create pattern
  > 220 │       const createSystem = async (testPage: any) => {
        │                                             ^^^
    221 │         const system = UnifiedDiagnosticSystem.getInstance(testPage);
    222 │         const initMethod = (
  
  i any disables many type checking rules. Its use should be avoided.
  

tests/unified-system-initialization.spec.ts:221:15 lint/nursery/noShadow ━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × This variable shadows another variable with the same name in the outer scope.
  
    219 │       // Similar to Context.create pattern
    220 │       const createSystem = async (testPage: any) => {
  > 221 │         const system = UnifiedDiagnosticSystem.getInstance(testPage);
        │               ^^^^^^
    222 │         const initMethod = (
    223 │           system as { initializeComponents: () => Promise<void> }
  
  i This is the shadowed variable, which is now inaccessible in the inner scope.
  
    10 │ test.describe('UnifiedSystem Initialization (Unit3)', () => {
  > 11 │   let system: UnifiedDiagnosticSystem;
       │       ^^^^^^
    12 │ 
    13 │   test.describe('initializeComponents method', () => {
  
  i Consider renaming this variable. It's easy to confuse the origin of variables if they share the same name.
  

Checked 175 files in 53ms. No fixes applied.
Found 355 errors.
Found 1 warning.
check ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  × Some errors were emitted while running checks.
  

